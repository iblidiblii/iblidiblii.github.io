<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Laberinto GPS</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      background: black;
    }
    canvas {
      display: block;
    }
    #counter {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-family: sans-serif;
      font-size: 18px;
      background: rgba(0, 0, 0, 0.5);
      padding: 6px 12px;
      border-radius: 8px;
    }
    .controls {
      position: absolute;
      bottom: 10px;
      left: 10px;
    }
    .controls button {
      font-size: 16px;
      margin: 4px;
      padding: 10px;
    }
  </style>
</head>
<body>
<canvas id="mazeCanvas"></canvas>
<div id="counter">Nuevo laberinto en: 60</div>
<div class="controls">
  <button onclick="simulateMove('up')">Simular Arriba</button>
  <button onclick="simulateMove('right')">Simular Derecha</button>
</div>
<script>
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");

let cols = 31;
let rows = 31;
let cellSize = 20;
let maze = [];
let currentMaze = [];
let player = { x: Math.floor(cols / 2), y: Math.floor(rows / 2) };
let exitCell = { x: 0, y: 0 };
let visibleCells = 15;
let transitionDuration = 1000;
let transitionStart = null;
let transitioning = false;
let timer = 60;
let gpsOrigin = null;
let lastPlayerPos = { ...player };

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

class Cell {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.walls = [true, true, true, true];
    this.visited = false;
  }

  draw(offsetX, offsetY, color = "white") {
    const x = this.x * cellSize - offsetX;
    const y = this.y * cellSize - offsetY;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;

    if (this.walls[0]) drawLine(x, y, x + cellSize, y);        // top
    if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize); // right
    if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize); // bottom
    if (this.walls[3]) drawLine(x, y + cellSize, x, y);        // left
  }
}

function drawLine(x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}

function index(x, y) {
  if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
  return x + y * cols;
}

function generateMaze() {
  maze = Array(cols * rows).fill().map((_, i) => new Cell(i % cols, Math.floor(i / cols)));
  let stack = [];
  let current = maze[0];
  current.visited = true;

  while (true) {
    const neighbors = [];
    const directions = [
      [0, -1, 0],
      [1, 0, 1],
      [0, 1, 2],
      [-1, 0, 3]
    ];

    for (let [dx, dy, dir] of directions) {
      const nx = current.x + dx;
      const ny = current.y + dy;
      const neighbor = maze[index(nx, ny)];
      if (neighbor && !neighbor.visited) neighbors.push([neighbor, dir]);
    }

    if (neighbors.length > 0) {
      const [next, dir] = neighbors[Math.floor(Math.random() * neighbors.length)];
      current.walls[dir] = false;
      next.walls[(dir + 2) % 4] = false;
      stack.push(current);
      current = next;
      current.visited = true;
    } else if (stack.length > 0) {
      current = stack.pop();
    } else break;
  }

  exitCell = { x: Math.floor(Math.random() * cols), y: 0 };
  maze[index(exitCell.x, exitCell.y)].walls[0] = false;
  currentMaze = maze;
}

function drawMaze() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const offsetX = (player.x * cellSize) - canvas.width / 2 + cellSize / 2;
  const offsetY = (player.y * cellSize) - canvas.height / 2 + cellSize / 2;

  for (let cell of currentMaze) cell.draw(offsetX, offsetY);
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(canvas.width / 2, canvas.height / 2, cellSize / 4, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "lime";
  const exitX = exitCell.x * cellSize - offsetX;
  const exitY = exitCell.y * cellSize - offsetY;
  ctx.beginPath();
  ctx.arc(exitX + cellSize / 2, exitY + cellSize / 2, 4, 0, Math.PI * 2);
  ctx.fill();
}

function canMove(x, y) {
  if (x < 0 || y < 0 || x >= cols || y >= rows) return false;
  return true;
}

function movePlayer(dir) {
  const cell = currentMaze[index(player.x, player.y)];
  let dx = 0, dy = 0, wallIndex;

  if (dir === "up") [dy, wallIndex] = [-1, 0];
  if (dir === "right") [dx, wallIndex] = [1, 1];
  if (dir === "down") [dy, wallIndex] = [1, 2];
  if (dir === "left") [dx, wallIndex] = [-1, 3];

  const nx = player.x + dx;
  const ny = player.y + dy;

  if (!canMove(nx, ny)) return;
  if (!cell.walls[wallIndex]) player = { x: nx, y: ny };
}

function simulateMove(direction) {
  movePlayer(direction);
  drawMaze();
}

function updateTimer() {
  timer--;
  document.getElementById("counter").innerText = `Nuevo laberinto en: ${timer}`;
  if (timer <= 0) {
    generateMaze();
    timer = 60;
  }
  setTimeout(updateTimer, 1000);
}

function watchPosition() {
  if (!navigator.geolocation) return;
  navigator.geolocation.watchPosition(pos => {
    const { latitude, longitude } = pos.coords;

    if (!gpsOrigin) {
      gpsOrigin = { lat: latitude, lon: longitude };
      return;
    }

    const dx = longitude - gpsOrigin.lon;
    const dy = latitude - gpsOrigin.lat;
    const threshold = 0.00005;

    if (dy < -threshold) simulateMove("up");
    else if (dy > threshold) simulateMove("down");
    else if (dx < -threshold) simulateMove("left");
    else if (dx > threshold) simulateMove("right");

    gpsOrigin = { lat: latitude, lon: longitude };
  }, console.error, { enableHighAccuracy: true, maximumAge: 1000 });
}

generateMaze();
drawMaze();
updateTimer();
watchPosition();
</script>
</body>
</html>
