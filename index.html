<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Laberinto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: white;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: white;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let w = canvas.width = window.innerWidth;
let h = canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
});

const mazeSize = 41; // Odd number for full walls around
const cellSize = 10;
let maze = [];
let seed = Date.now();
let player = {
  x: Math.floor(mazeSize / 2),
  y: Math.floor(mazeSize / 2),
  angle: 0,
  targetAngle: 0,
};
let direction = { x: 0, y: 0 };

function seededRandom(seed) {
  return () => {
    seed = (seed * 16807) % 2147483647;
    return (seed - 1) / 2147483646;
  };
}

function generateMaze() {
  const rand = seededRandom(seed);
  maze = Array(mazeSize).fill(0).map(() => Array(mazeSize).fill(1));
  function carve(x, y) {
    const dirs = [
      [0, -2], [2, 0], [0, 2], [-2, 0]
    ].sort(() => rand() - 0.5);
    for (let [dx, dy] of dirs) {
      const nx = x + dx, ny = y + dy;
      if (ny > 0 && ny < mazeSize-1 && nx > 0 && nx < mazeSize-1 && maze[ny][nx] === 1) {
        maze[ny][nx] = 0;
        maze[y + dy/2][x + dx/2] = 0;
        carve(nx, ny);
      }
    }
  }
  maze[player.y][player.x] = 0;
  carve(player.x, player.y);
}
generateMaze();


function drawMaze() {
  const camX = player.x * cellSize;
  const camY = player.y * cellSize;
  const offsetX = canvas.width / 2 - camX - cellSize / 2;
  const offsetY = canvas.height / 2 - camY - cellSize / 2;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(offsetX, offsetY);

  // Laberinto con líneas finas
  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;
  for (let y = 0; y < mazeSize; y++) {
    for (let x = 0; x < mazeSize; x++) {
      if (maze[y][x] === 1) {
        ctx.beginPath();
        ctx.rect(x * cellSize, y * cellSize, cellSize, cellSize);
        ctx.stroke();
      }
    }
  }

  // Salida
  ctx.fillStyle = "green";
  ctx.beginPath();
  ctx.arc(
    exit.x * cellSize + cellSize / 2,
    exit.y * cellSize + cellSize / 2,
    cellSize / 4,
    0,
    Math.PI * 2
  );
  ctx.fill();

  // Jugador (triángulo)
  ctx.fillStyle = "blue";
  ctx.beginPath();
  const px = player.x * cellSize + cellSize / 2;
  const py = player.y * cellSize + cellSize / 2;
  const s = cellSize / 2;
  ctx.save();
  ctx.translate(px, py);
  let angle = 0;
  if (player.dir === "up") angle = 0;
  else if (player.dir === "right") angle = Math.PI / 2;
  else if (player.dir === "down") angle = Math.PI;
  else if (player.dir === "left") angle = -Math.PI / 2;
  ctx.rotate(angle);
  ctx.moveTo(0, -s / 1.5);
  ctx.lineTo(-s / 2.5, s / 2);
  ctx.lineTo(s / 2.5, s / 2);
  ctx.closePath();
  ctx.fill();
  ctx.restore();

  // Pista (gradiente direccional)
  if (showHint) {
    const dx = exit.x - player.x;
    const dy = exit.y - player.y;
    const mag = Math.sqrt(dx * dx + dy * dy);
    if (mag > 0) {
      const nx = dx / mag;
      const ny = dy / mag;
      const gx = px + nx * cellSize * 3;
      const gy = py + ny * cellSize * 3;
      let grad = ctx.createLinearGradient(px, py, gx, gy);
      grad.addColorStop(0, "rgba(0,255,0,0.3)");
      grad.addColorStop(1, "rgba(0,255,0,0)");
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(px, py, cellSize * 3, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();

  if (isFading) {
    ctx.fillStyle = `rgba(0, 0, 0, ${fadeOpacity})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}
function movePlayer() {
  const nx = player.x + direction.x;
  const ny = player.y + direction.y;
  if (maze[ny] && maze[ny][nx] === 0) {
    player.x = nx;
    player.y = ny;
    const angleMap = { "0,-1": -Math.PI/2, "1,0": 0, "0,1": Math.PI/2, "-1,0": Math.PI };
    player.targetAngle = angleMap[`${direction.x},${direction.y}`] || player.angle;
  }
}

setInterval(() => {
  if (direction.x !== 0 || direction.y !== 0) {
    movePlayer();
  }
}, 150);

function update() {
  drawMaze();
  requestAnimationFrame(update);
}
update();

// Movimiento por pulsación táctil o ratón
canvas.addEventListener("mousedown", handleClick);
canvas.addEventListener("touchstart", e => handleClick(e.touches[0]));

function handleClick(e) {
  const cx = w / 2, cy = h / 2;
  const dx = e.clientX - cx;
  const dy = e.clientY - cy;
  if (Math.abs(dx) > Math.abs(dy)) {
    direction = dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 };
  } else {
    direction = dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 };
  }
}

canvas.addEventListener("mouseup", () => direction = { x: 0, y: 0 });
canvas.addEventListener("touchend", () => direction = { x: 0, y: 0 });

// Teclado
document.addEventListener("keydown", e => {
  if (e.key === "ArrowUp") direction = { x: 0, y: -1 };
  if (e.key === "ArrowDown") direction = { x: 0, y: 1 };
  if (e.key === "ArrowLeft") direction = { x: -1, y: 0 };
  if (e.key === "ArrowRight") direction = { x: 1, y: 0 };
});
document.addEventListener("keyup", () => direction = { x: 0, y: 0 });
</script>
</body>
</html>
