<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Laberinto con cámara centrada</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: white;
    }
    canvas {
      display: block;
      background: white;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let cols = 31;
    let rows = 31;
    const cellSize = 20;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const maze = [];
    const stack = [];

    function Cell(x, y) {
      this.x = x;
      this.y = y;
      this.visited = false;
      this.walls = [true, true, true, true]; // top, right, bottom, left

      this.checkNeighbors = function () {
        const neighbors = [];

        const top    = maze[index(x, y - 1)];
        const right  = maze[index(x + 1, y)];
        const bottom = maze[index(x, y + 1)];
        const left   = maze[index(x - 1, y)];

        if (top && !top.visited) neighbors.push(top);
        if (right && !right.visited) neighbors.push(right);
        if (bottom && !bottom.visited) neighbors.push(bottom);
        if (left && !left.visited) neighbors.push(left);

        if (neighbors.length > 0) {
          return neighbors[Math.floor(Math.random() * neighbors.length)];
        } else {
          return undefined;
        }
      };
    }

    function index(x, y) {
      if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
      return x + y * cols;
    }

    function removeWalls(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;

      if (dx === 1) {
        a.walls[3] = false;
        b.walls[1] = false;
      } else if (dx === -1) {
        a.walls[1] = false;
        b.walls[3] = false;
      }
      if (dy === 1) {
        a.walls[0] = false;
        b.walls[2] = false;
      } else if (dy === -1) {
        a.walls[2] = false;
        b.walls[0] = false;
      }
    }

    // Crear celdas
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        maze.push(new Cell(x, y));
      }
    }

    let current = maze[0];
    current.visited = true;

    function generateMaze() {
      const next = current.checkNeighbors();
      if (next) {
        next.visited = true;
        stack.push(current);
        removeWalls(current, next);
        current = next;
      } else if (stack.length > 0) {
        current = stack.pop();
      }
    }

    // Jugador
    let player = {
      x: Math.floor(cols / 2),
      y: Math.floor(rows / 2)
    };

    // Salida aleatoria en una esquina
    const corners = [
      { x: 0, y: 0 },
      { x: cols - 1, y: 0 },
      { x: 0, y: rows - 1 },
      { x: cols - 1, y: rows - 1 }
    ];
    const exit = corners[Math.floor(Math.random() * corners.length)];

    // Dibujar
    function drawMaze() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const offsetX = canvas.width / 2 - player.x * cellSize - cellSize / 2;
      const offsetY = canvas.height / 2 - player.y * cellSize - cellSize / 2;

      ctx.save();
      ctx.translate(offsetX, offsetY);

      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;

      for (let cell of maze) {
        const x = cell.x * cellSize;
        const y = cell.y * cellSize;

        if (cell.walls[0]) {
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + cellSize, y);
          ctx.stroke();
        }
        if (cell.walls[1]) {
          ctx.beginPath();
          ctx.moveTo(x + cellSize, y);
          ctx.lineTo(x + cellSize, y + cellSize);
          ctx.stroke();
        }
        if (cell.walls[2]) {
          ctx.beginPath();
          ctx.moveTo(x + cellSize, y + cellSize);
          ctx.lineTo(x, y + cellSize);
          ctx.stroke();
        }
        if (cell.walls[3]) {
          ctx.beginPath();
          ctx.moveTo(x, y + cellSize);
          ctx.lineTo(x, y);
          ctx.stroke();
        }
      }

      // Dibujar salida
      ctx.fillStyle = "green";
      ctx.fillRect(exit.x * cellSize + cellSize * 0.25, exit.y * cellSize + cellSize * 0.25, cellSize * 0.5, cellSize * 0.5);

      // Dibujar jugador
      const px = player.x * cellSize + cellSize / 2;
      const py = player.y * cellSize + cellSize / 2;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.moveTo(px, py - 6);
      ctx.lineTo(px - 5, py + 5);
      ctx.lineTo(px + 5, py + 5);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function gameLoop() {
      for (let i = 0; i < 10; i++) generateMaze(); // Rápido

      drawMaze();
      requestAnimationFrame(gameLoop);
    }

    // Movimiento
    document.addEventListener("keydown", (e) => {
      const cell = maze[index(player.x, player.y)];
      if (e.key === "ArrowUp" && !cell.walls[0]) player.y--;
      if (e.key === "ArrowRight" && !cell.walls[1]) player.x++;
      if (e.key === "ArrowDown" && !cell.walls[2]) player.y++;
      if (e.key === "ArrowLeft" && !cell.walls[3]) player.x--;
    });

    gameLoop();
  </script>
</body>
</html>
