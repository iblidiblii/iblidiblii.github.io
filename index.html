<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Laberinto GPS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
      touch-action: none;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: sans-serif;
      z-index: 10;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="info">Lat: 0<br>Lon: 0<br>Pasos: 0</div>
<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let width, height;
  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
  }
  window.addEventListener('resize', resize);
  resize();

  const cellSize = 10; // tamaño del laberinto en celdas
  const maze = [];
  const visited = [];
  const directions = [[0,-1],[1,0],[0,1],[-1,0]];
  const player = {
    x: Math.floor(cellSize / 2),
    y: Math.floor(cellSize / 2),
    screenX: 0,
    screenY: 0,
    angle: 0
  };
  let steps = 0;
  let prevLat = null, prevLon = null;
  let exitCell = {x: 0, y: 0};

  function generateMaze() {
    for (let y = 0; y < cellSize; y++) {
      maze[y] = [];
      visited[y] = [];
      for (let x = 0; x < cellSize; x++) {
        maze[y][x] = [true, true, true, true]; // top, right, bottom, left
        visited[y][x] = false;
      }
    }
    function dfs(x, y) {
      visited[y][x] = true;
      const dirs = directions.map((_, i) => i).sort(() => Math.random() - 0.5);
      for (const i of dirs) {
        const nx = x + directions[i][0];
        const ny = y + directions[i][1];
        if (nx >= 0 && ny >= 0 && nx < cellSize && ny < cellSize && !visited[ny][nx]) {
          maze[y][x][i] = false;
          maze[ny][nx][(i + 2) % 4] = false;
          dfs(nx, ny);
        }
      }
    }
    dfs(player.x, player.y);
    // salida en esquina
    exitCell = {x: cellSize - 1, y: cellSize - 1};
    maze[exitCell.y][exitCell.x][1] = false; // abrir derecha
  }

  function drawMaze() {
    const scale = Math.min(width, height) / 10;
    const offsetX = width / 2 - player.x * scale;
    const offsetY = height / 2 - player.y * scale;

    ctx.clearRect(0, 0, width, height);
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let y = 0; y < cellSize; y++) {
      for (let x = 0; x < cellSize; x++) {
        const [top, right, bottom, left] = maze[y][x];
        const sx = x * scale + offsetX;
        const sy = y * scale + offsetY;
        if (top) { ctx.moveTo(sx, sy); ctx.lineTo(sx + scale, sy); }
        if (right) { ctx.moveTo(sx + scale, sy); ctx.lineTo(sx + scale, sy + scale); }
        if (bottom) { ctx.moveTo(sx + scale, sy + scale); ctx.lineTo(sx, sy + scale); }
        if (left) { ctx.moveTo(sx, sy + scale); ctx.lineTo(sx, sy); }
      }
    }
    ctx.stroke();

    // salida
    ctx.fillStyle = 'lime';
    ctx.beginPath();
    ctx.arc(exitCell.x * scale + offsetX + scale / 2, exitCell.y * scale + offsetY + scale / 2, 5, 0, Math.PI * 2);
    ctx.fill();

    // jugador (triángulo)
    const px = player.x * scale + offsetX + scale / 2;
    const py = player.y * scale + offsetY + scale / 2;
    const r = scale * 0.4;
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.moveTo(px + r * Math.cos(player.angle), py + r * Math.sin(player.angle));
    ctx.lineTo(px + r * 0.5 * Math.cos(player.angle + Math.PI * 2 / 3), py + r * 0.5 * Math.sin(player.angle + Math.PI * 2 / 3));
    ctx.lineTo(px + r * 0.5 * Math.cos(player.angle - Math.PI * 2 / 3), py + r * 0.5 * Math.sin(player.angle - Math.PI * 2 / 3));
    ctx.closePath();
    ctx.fill();
  }

  function canMove(dx, dy) {
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (nx < 0 || ny < 0 || nx >= cellSize || ny >= cellSize) return false;
    if (dx === 1 && maze[player.y][player.x][1]) return false;
    if (dx === -1 && maze[player.y][player.x][3]) return false;
    if (dy === 1 && maze[player.y][player.x][2]) return false;
    if (dy === -1 && maze[player.y][player.x][0]) return false;
    return true;
  }

  function updatePosition(lat, lon) {
    const info = document.getElementById("info");
    info.innerHTML = `Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}<br>Pasos: ${steps}`;
    if (prevLat !== null && prevLon !== null) {
      const dLat = (lat - prevLat) * 111139; // approx meters
      const dLon = (lon - prevLon) * 111139 * Math.cos(lat * Math.PI / 180);
      const dist = Math.sqrt(dLat * dLat + dLon * dLon);
      const angle = Math.atan2(dLat, dLon);
      const diff = Math.abs((angle - player.angle + Math.PI * 3) % (2 * Math.PI) - Math.PI);
      if (dist > 0.5 && diff < Math.PI / 4) {
        // mover hacia adelante
        const dx = Math.round(Math.cos(player.angle));
        const dy = Math.round(Math.sin(player.angle));
        if (canMove(dx, dy)) {
          player.x += dx;
          player.y += dy;
          steps++;
        }
      }
    }
    prevLat = lat;
    prevLon = lon;
  }

  navigator.geolocation.watchPosition(pos => {
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;
    updatePosition(lat, lon);
  }, console.error, {
    enableHighAccuracy: true,
    maximumAge: 1000,
    timeout: 27000
  });

  window.addEventListener('deviceorientation', (e) => {
    if (e.absolute || e.alpha != null) {
      player.angle = ((e.alpha ?? 0) * Math.PI / 180);
    }
  });

  function loop() {
    drawMaze();
    requestAnimationFrame(loop);
  }

  generateMaze();
  loop();
</script>
</body>
</html>
