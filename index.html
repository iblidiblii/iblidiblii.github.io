<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Laberinto GPS</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 5px;
      right: 5px;
      color: white;
      font-size: 12px;
      font-family: sans-serif;
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">Pasos: 0<br>Lat: --<br>Lon: --</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    function resizeCanvas() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const cols = 20;
    const rows = 20;
    const maze = [];
    let cellSize;
    let player = { x: Math.floor(cols / 2), y: Math.floor(rows / 2) };
    let angle = 0;
    let lat0 = null, lon0 = null;
    let steps = 0;
    const info = document.getElementById("info");

    function createMaze() {
      for (let y = 0; y < rows; y++) {
        maze[y] = [];
        for (let x = 0; x < cols; x++) {
          maze[y][x] = { top: true, right: true, bottom: true, left: true, visited: false };
        }
      }

      function carve(x, y) {
        maze[y][x].visited = true;
        const dirs = ['top', 'right', 'bottom', 'left'].sort(() => Math.random() - 0.5);
        for (let dir of dirs) {
          let nx = x, ny = y;
          if (dir === 'top') ny--;
          if (dir === 'right') nx++;
          if (dir === 'bottom') ny++;
          if (dir === 'left') nx--;
          if (nx >= 0 && ny >= 0 && nx < cols && ny < rows && !maze[ny][nx].visited) {
            maze[y][x][dir] = false;
            if (dir === 'top') maze[ny][nx].bottom = false;
            if (dir === 'right') maze[ny][nx].left = false;
            if (dir === 'bottom') maze[ny][nx].top = false;
            if (dir === 'left') maze[ny][nx].right = false;
            carve(nx, ny);
          }
        }
      }

      carve(player.x, player.y);
    }

    createMaze();

    function drawMaze() {
      cellSize = Math.min(width, height) / 10;

      ctx.save();
      ctx.translate(width / 2, height / 2);
      ctx.rotate(angle);
      ctx.translate(-player.x * cellSize - cellSize / 2, -player.y * cellSize - cellSize / 2);

      ctx.clearRect(player.x * cellSize - width / 2, player.y * cellSize - height / 2, width, height);
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = maze[y][x];
          const px = x * cellSize;
          const py = y * cellSize;
          if (cell.top) {
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px + cellSize, py);
            ctx.stroke();
          }
          if (cell.right) {
            ctx.beginPath();
            ctx.moveTo(px + cellSize, py);
            ctx.lineTo(px + cellSize, py + cellSize);
            ctx.stroke();
          }
          if (cell.bottom) {
            ctx.beginPath();
            ctx.moveTo(px, py + cellSize);
            ctx.lineTo(px + cellSize, py + cellSize);
            ctx.stroke();
          }
          if (cell.left) {
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px, py + cellSize);
            ctx.stroke();
          }
        }
      }

      // Dibujar el jugador como triÃ¡ngulo
      const cx = player.x * cellSize + cellSize / 2;
      const cy = player.y * cellSize + cellSize / 2;
      ctx.fillStyle = 'red';
      ctx.beginPath();
      const r = cellSize / 3;
      ctx.moveTo(cx + r, cy);
      ctx.lineTo(cx - r / 2, cy - r);
      ctx.lineTo(cx - r / 2, cy + r);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function movePlayer(dx, dy) {
      const x = player.x;
      const y = player.y;
      const nextX = x + dx;
      const nextY = y + dy;
      const current = maze[y][x];

      if (dx === 1 && !current.right && nextX < cols) player.x++;
      if (dx === -1 && !current.left && nextX >= 0) player.x--;
      if (dy === 1 && !current.bottom && nextY < rows) player.y++;
      if (dy === -1 && !current.top && nextY >= 0) player.y--;
    }

    function updatePosition(pos) {
      const { latitude, longitude } = pos.coords;
      info.innerHTML = `Pasos: ${steps}<br>Lat: ${latitude.toFixed(5)}<br>Lon: ${longitude.toFixed(5)}`;
      if (lat0 === null || lon0 === null) {
        lat0 = latitude;
        lon0 = longitude;
        return;
      }
      const R = 6371000; // metros
      const toRad = deg => deg * Math.PI / 180;
      const dLat = toRad(latitude - lat0);
      const dLon = toRad(longitude - lon0);
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat0)) * Math.cos(toRad(latitude)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const d = R * c;

      if (d >= 1) {
        const bearing = Math.atan2(
          Math.sin(dLon) * Math.cos(toRad(latitude)),
          Math.cos(toRad(lat0)) * Math.sin(toRad(latitude)) -
          Math.sin(toRad(lat0)) * Math.cos(toRad(latitude)) * Math.cos(dLon)
        );
        const dir = (bearing * 180 / Math.PI + 360) % 360;
        if (dir >= 45 && dir < 135) movePlayer(1, 0);       // Este
        else if (dir >= 135 && dir < 225) movePlayer(0, 1); // Sur
        else if (dir >= 225 && dir < 315) movePlayer(-1, 0); // Oeste
        else movePlayer(0, -1);                             // Norte

        steps++;
        lat0 = latitude;
        lon0 = longitude;
      }
    }

    navigator.geolocation.watchPosition(updatePosition, console.error, {
      enableHighAccuracy: true,
      maximumAge: 1000,
      timeout: 27000
    });

    window.addEventListener("deviceorientation", e => {
      angle = -e.alpha * Math.PI / 180;
    });

    function loop() {
      drawMaze();
      requestAnimationFrame(loop);
    }
    loop();

    function regenerate() {
      createMaze();
      setTimeout(regenerate, 60000); // cada minuto
    }
    setTimeout(regenerate, 60000);
  </script>
</body>
</html>
