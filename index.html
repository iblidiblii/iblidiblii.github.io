<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Laberinto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: white;
      overflow: hidden;
      touch-action: none;
    }

    canvas {
      display: block;
      background: white;
    }

    #fade {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      opacity: 0;
      pointer-events: none;
      transition: opacity 3s ease;
      z-index: 10;
    }

    #gradientHint {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      opacity: 0;
      z-index: 9;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="fade"></div>
  <canvas id="gradientHint"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const hintCanvas = document.getElementById('gradientHint');
    const hintCtx = hintCanvas.getContext('2d');
    const fade = document.getElementById('fade');

    let width, height;
    let mazeSize = 31; // Tamaño impar para caminos y paredes alternos
    let maze = [];
    let seed = Date.now();
    let rng = mulberry32(seed);
    let player = { x: Math.floor(mazeSize/2), y: Math.floor(mazeSize/2), angle: 0, targetAngle: 0 };
    let cellSize = 20;
    let cameraZoom = 8;
    let moving = { forward: false, backward: false, left: false, right: false };
    let exit = { x: 0, y: 0 };
    let lastMazeChange = Date.now();
    let lastHint = Date.now();

    // === CONFIGURACIÓN ===
    const HINT_INTERVAL = 30000; // Intervalo entre pistas (milisegundos)

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      hintCanvas.width = width;
      hintCanvas.height = height;
    }

    window.addEventListener('resize', resize);
    resize();

    function mulberry32(a) {
      return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function generateMaze() {
      maze = Array.from({ length: mazeSize }, () => Array(mazeSize).fill(1));

      function carve(x, y) {
        const dirs = [[0,-2],[2,0],[0,2],[-2,0]].sort(() => rng() - 0.5);
        for (let [dx, dy] of dirs) {
          let nx = x + dx, ny = y + dy;
          if (nx > 0 && nx < mazeSize - 1 && ny > 0 && ny < mazeSize - 1 && maze[ny][nx] === 1) {
            maze[ny][nx] = 0;
            maze[y + dy/2][x + dx/2] = 0;
            carve(nx, ny);
          }
        }
      }

      maze[player.y][player.x] = 0;
      carve(player.x, player.y);

      const corners = [
        { x: 1, y: 1 },
        { x: 1, y: mazeSize - 2 },
        { x: mazeSize - 2, y: 1 },
        { x: mazeSize - 2, y: mazeSize - 2 }
      ];
      exit = corners[Math.floor(rng() * corners.length)];
      maze[exit.y][exit.x] = 0;
    }

    function drawMaze() {
      ctx.clearRect(0, 0, width, height);

      const zoom = height / cameraZoom;
      const offsetX = width / 2 - player.x * zoom;
      const offsetY = height / 2 - player.y * zoom;

      ctx.save();
      ctx.translate(offsetX, offsetY);

      for (let y = 0; y < mazeSize; y++) {
        for (let x = 0; x < mazeSize; x++) {
          if (maze[y][x] === 1) {
            ctx.fillStyle = 'black';
            ctx.fillRect(x * zoom, y * zoom, zoom, zoom);
          }
        }
      }

      // Dibuja meta
      ctx.fillStyle = 'green';
      ctx.beginPath();
      ctx.arc(exit.x * zoom + zoom/2, exit.y * zoom + zoom/2, zoom/3, 0, Math.PI * 2);
      ctx.fill();

      // Dibuja personaje
      ctx.translate(player.x * zoom + zoom/2, player.y * zoom + zoom/2);
      ctx.rotate(player.angle);
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.moveTo(0, -zoom * 0.4);
      ctx.lineTo(zoom * 0.25, zoom * 0.4);
      ctx.lineTo(-zoom * 0.25, zoom * 0.4);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function step() {
      const now = Date.now();

      // Movimiento
      const speed = 0.05;
      let dx = Math.sin(player.angle);
      let dy = -Math.cos(player.angle);

      if (moving.forward || moving.backward) {
        let dir = moving.forward ? 1 : -1;
        let nx = player.x + dx * dir;
        let ny = player.y + dy * dir;
        let tx = Math.round(nx);
        let ty = Math.round(ny);

        if (maze[ty] && maze[ty][tx] === 0) {
          player.x = nx;
          player.y = ny;
        }
      }

      // Rotación
      if (moving.left) player.targetAngle -= 0.05;
      if (moving.right) player.targetAngle += 0.05;

      let delta = player.targetAngle - player.angle;
      player.angle += delta * 0.1;

      drawMaze();

      // Cambio de laberinto
      if (now - lastMazeChange > 60000) {
        fadeIn(() => {
          seed = Date.now();
          rng = mulberry32(seed);
          generateMaze();
          lastMazeChange = Date.now();
          fadeOut();
          navigator.vibrate?.(3000);
        });
      }

      // Mostrar pista
      if (now - lastHint > HINT_INTERVAL) {
        showHint();
        lastHint = Date.now();
      }

      requestAnimationFrame(step);
    }

    function fadeIn(callback) {
      fade.style.opacity = 1;
      setTimeout(callback, 3000);
    }

    function fadeOut() {
      fade.style.opacity = 0;
    }

    function showHint() {
      let angle = Math.atan2(exit.x - player.x, player.y - exit.y);
      hintCtx.clearRect(0, 0, width, height);
      let grad = hintCtx.createRadialGradient(width/2, height/2, 0, width/2, height/2, width);
      grad.addColorStop(0, 'rgba(255,255,0,0.3)');
      grad.addColorStop(1, 'rgba(255,255,0,0)');
      hintCtx.save();
      hintCtx.translate(width/2, height/2);
      hintCtx.rotate(angle);
      hintCtx.fillStyle = grad;
      hintCtx.fillRect(-width, -height, width*2, height*2);
      hintCtx.restore();
      hintCanvas.style.opacity = 1;
      navigator.vibrate?.([200, 200, 200]);
      setTimeout(() => hintCanvas.style.opacity = 0, 3000);
    }

    canvas.addEventListener('touchstart', e => {
      const x = e.touches[0].clientX;
      const y = e.touches[0].clientY;
      const third = width / 3;
      if (x < third) moving.left = true;
      else if (x > 2 * third) moving.right = true;
      else if (y < height / 2) moving.forward = true;
      else moving.backward = true;
    });

    canvas.addEventListener('touchend', () => {
      moving = { forward: false, backward: false, left: false, right: false };
    });

    generateMaze();
    requestAnimationFrame(step);
  </script>
</body>
</html>
