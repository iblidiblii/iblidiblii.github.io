<!DOCTYPE html> 
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Laberinto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: white;
      touch-action: manipulation;
    }
    canvas {
      display: block;
      
      position:absolute;
    }
    #fog{
      pointer-events: none;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<canvas id ="fog">hola</canvas>
<canvas id="pista" style="position:absolute; top:0; left:0; pointer-events:none; z-index:3;"></canvas>
  

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

const fogCanvas = document.getElementById('fog');
const fogCtx = fogCanvas.getContext('2d');
fogCanvas.width = width;
fogCanvas.height = height;


const pistaCanvas = document.getElementById("pista");
const pistaCtx = pistaCanvas.getContext("2d");
pistaCanvas.width = width;
pistaCanvas.height = height;


const hintTime = 5000;
  
// Tamaño del laberinto y celdas
const size = 21
const cols = size;
const rows = size;
const cellSize = Math.floor(height / 15);
const map = [];
let player = { x: Math.floor(cols/2), y: Math.floor(rows/2) };
  
let cameraX = player.x;
let cameraY = player.y;

let hasWon = false;
  
// Salida en una esquina aleatoria
const corners = [
  { x: 0, y: 0 },
  { x: cols - 1, y: 0 },
  { x: 0, y: rows - 1 },
  { x: cols - 1, y: rows - 1 }
];
const exit = corners[Math.floor(Math.random() * corners.length)];

// Generador básico de laberinto (DFS)
function generateMaze() {
  for (let y = 0; y < rows; y++) {
    map[y] = [];
    for (let x = 0; x < cols; x++) {
      map[y][x] = { top: true, right: true, bottom: true, left: true, visited: false };
    }
  }

  function visit(x, y) {
    map[y][x].visited = true;
    const dirs = ['top', 'right', 'bottom', 'left'].sort(() => 0.5 - Math.random());
    for (let dir of dirs) {
      let nx = x, ny = y;
      if (dir === 'top') ny--;
      if (dir === 'right') nx++;
      if (dir === 'bottom') ny++;
      if (dir === 'left') nx--;

      if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && !map[ny][nx].visited) {
        map[y][x][dir] = false;
        if (dir === 'top') map[ny][nx].bottom = false;
        if (dir === 'right') map[ny][nx].left = false;
        if (dir === 'bottom') map[ny][nx].top = false;
        if (dir === 'left') map[ny][nx].right = false;
        visit(nx, ny);
      }
    }
  }

  visit(0, 0);
}

generateMaze();

// Dibujo del laberinto con líneas
function drawMaze(centerX, centerY) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 1;

  const offsetX = width / 2 - centerX * cellSize - cellSize / 2;
  const offsetY = height / 2 - centerY * cellSize - cellSize / 2;

  ctx.save();
  ctx.translate(offsetX, offsetY);
  
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const cell = map[y][x];
      const px = x * cellSize;
      const py = y * cellSize;

      if (cell.top) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + cellSize, py);
        ctx.stroke();
      }
      if (cell.right) {
        ctx.beginPath();
        ctx.moveTo(px + cellSize, py);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.bottom) {
        ctx.beginPath();
        ctx.moveTo(px, py + cellSize);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.left) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px, py + cellSize);
        ctx.stroke();
      }
    }
  }

  // Dibujar salida
  ctx.fillStyle = 'red';
  ctx.beginPath();
  ctx.arc(exit.x * cellSize + cellSize / 2, exit.y * cellSize + cellSize / 2, cellSize / 4, 0, Math.PI * 2);
  ctx.fill();

  // Dibujar jugador
  ctx.fillStyle = 'blue';
  ctx.beginPath();
  ctx.arc(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2, cellSize / 4, 0, Math.PI * 2);
  ctx.fill();

  
  ctx.restore();
}

// Movimiento
function movePlayer(dx, dy) {
  
  while (true) {
    const cell = map[player.y][player.x];
    let nextX = player.x + dx;
    let nextY = player.y + dy;

    if (nextX < 0 || nextX >= cols || nextY < 0 || nextY >= rows) break;

    const nextCell = map[nextY][nextX];

    const wall =
      (dx === -1 && cell.left) ||
      (dx === 1 && cell.right) ||
      (dy === -1 && cell.top) ||
      (dy === 1 && cell.bottom);

    if (wall) break;

    const exits = [
      !nextCell.top,
      !nextCell.right,
      !nextCell.bottom,
      !nextCell.left
    ].filter(Boolean).length;

    player.x = nextX;
    player.y = nextY;

    if (exits > 2 || (dx !== 0 && (!nextCell.left || !nextCell.right)) || (dy !== 0 && (!nextCell.top || !nextCell.bottom))) break;
  }
 if (player.x === exit.x && player.y === exit.y && !hasWon) {
  hasWon = true;
 }
}

// Tocar pantalla para mover
canvas.addEventListener('touchstart', e => {
  const x = e.touches[0].clientX;
  const y = e.touches[0].clientY;
  if (y < height * 0.25) movePlayer(0, -1);
  else if (y > height * 0.75) movePlayer(0, 1);
  else if (x < width * 0.25) movePlayer(-1, 0);
  else if (x > width * 0.75) movePlayer(1, 0);
});


  
  function drawPista() {
    pistaCtx.clearRect(0, 0, pistaCanvas.width, pistaCanvas.height);

    const dx = exit.x - player.x;
    const dy = exit.y - player.y;
    const angle = Math.atan2(dy, dx);

    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    const innerOffset = 40; // distancia desde el jugador
    const radius = 160;     // radio total del haz
    const angleWidth = Math.PI / 4; // apertura del haz (más = más ancho)

    // Punto central desplazado donde empieza el haz
    const arcX = cx + Math.cos(angle) * innerOffset;
    const arcY = cy + Math.sin(angle) * innerOffset;

    // Crear un gradiente radial suave
    const gradient = pistaCtx.createRadialGradient(
        arcX, arcY, radius * 0.2,
        arcX, arcY, radius
    );
    gradient.addColorStop(0, 'rgba(0,255,0,0.3)');
    gradient.addColorStop(1, 'rgba(0,255,0,0)');

    pistaCtx.fillStyle = gradient;

    // Dibujar una forma de "cuarto de círculo difuminado"
    pistaCtx.beginPath();
    pistaCtx.moveTo(arcX, arcY);
    pistaCtx.arc(arcX, arcY, radius, angle - angleWidth, angle + angleWidth, false);
    
    // Borde curvado de cierre en la parte interna
    const backRadius = radius * 0.5;
    const backAngle = angle + angleWidth;
    const backX = arcX + Math.cos(backAngle) * backRadius;
    const backY = arcY + Math.sin(backAngle) * backRadius;
    pistaCtx.quadraticCurveTo(arcX, arcY, backX, backY);

    pistaCtx.closePath();
    pistaCtx.fill();
  }
  
  

// Mostrar pista visual (cono con gradiente apuntando a la salida) cada 30 segundos
function mostrarPista() {
    drawPista();
    navigator.vibrate?.([100, 100, 100]); // tres pulsos
  
    setTimeout(() => {
        pistaCtx.clearRect(0, 0, pistaCanvas.width, pistaCanvas.height);
    }, 3000);
}

setInterval(mostrarPista, 5000); // cada 3 segundos




  // Overlay para fade
const fadeOverlay = document.createElement('div');
fadeOverlay.style.position = 'absolute';
fadeOverlay.style.top = '0';
fadeOverlay.style.left = '0';
fadeOverlay.style.width = '100%';
fadeOverlay.style.height = '100%';
fadeOverlay.style.backgroundColor = 'black';
fadeOverlay.style.opacity = '0';
fadeOverlay.style.transition = 'opacity 1.5s ease';
fadeOverlay.style.pointerEvents = 'none';
document.body.appendChild(fadeOverlay);

// Redibujar laberinto cada 60 segundos con fade y vibración
setInterval(() => {
  // Vibración si es compatible
  if (navigator.vibrate) {
    navigator.vibrate(3000);
  }

  // Fade a negro
  fadeOverlay.style.opacity = '1';

  setTimeout(() => {
    // Guardar posición del jugador y salida
    const oldPlayer = { x: player.x, y: player.y };
    const oldExit = { x: exit.x, y: exit.y };

    // Regenerar el laberinto
    generateMaze();

    // Restaurar posiciones
    player.x = oldPlayer.x;
    player.y = oldPlayer.y;
    exit.x = oldExit.x;
    exit.y = oldExit.y;

    drawMaze(player.x, player.y);

    // Fade out (volver a ver)
    fadeOverlay.style.opacity = '0';
  }, 1500); // Esperar mitad del tiempo en negro
}, 60000);

function drawFog(centerX, centerY) {
  fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);

  const radius = cellSize * 4; // radio de visibilidad
  const gradient = fogCtx.createRadialGradient(
    width / 2, height / 2, 0,      // centro en la pantalla
    width / 2, height / 2, radius  // borde exterior del gradiente
  );

  gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0.95)');

  fogCtx.fillStyle = gradient;
  fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);
}
  

function drawWinMessage() {

  const message = "Enhorabona, has eixit!";
  const boxWidth = 400;
  const boxHeight = 150;
  const x = (width - boxWidth) / 2;
  const y = (height - boxHeight) / 2;

  // Fondo con sombra
  fogCtx.save();
  fogCtx.shadowColor = "rgba(0, 0, 0, 0.5)";
  fogCtx.shadowBlur = 20;
  fogCtx.fillStyle = "rgba(255, 255, 255, 0.95)";
  fogCtx.strokeStyle = "#333";
  fogCtx.lineWidth = 4;

  // Rectángulo redondeado
  fogCtx.beginPath();
  fogCtx.roundRect(x, y, boxWidth, boxHeight, 25);
  fogCtx.fill();
  fogCtx.stroke();
  fogCtx.restore();

  // Texto centrado
  fogCtx.fillStyle = "#222";
  fogCtx.font = "28px Calibri, sans-serif";
  fogCtx.textAlign = "center";
  fogCtx.textBaseline = "middle";
  fogCtx.fillText(message, width / 2, height / 2);
  
}
  
  
// Inicial
function animate() {
  // Interpolación suave (easing)
  const speed = 0.1;
  cameraX += (player.x - cameraX) * speed;
  cameraY += (player.y - cameraY) * speed;

  drawMaze(cameraX, cameraY);
  drawFog(cameraX, cameraY);
  if (hasWon) {
    if (navigator.vibrate) {
    navigator.vibrate(3000);
    }
  drawWinMessage();
  }
  
  
  requestAnimationFrame(animate);
}
animate();


// Evitar zoom por doble click en móviles
document.addEventListener('dblclick', function (e) {
  e.preventDefault();
}, { passive: false });


document.addEventListener("gesturestart", function (e) {
  e.preventDefault();
});


  
</script>
</body>
</html>
