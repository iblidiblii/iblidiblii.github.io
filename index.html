<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Laberinto GPS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      color: white;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      transform-origin: center center;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      font-size: 14px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <canvas id="mazeCanvas"></canvas>
  <div id="info">
    <div id="coords">Lat: --, Lon: --</div>
    <div id="steps">Pasos: 0</div>
  </div>

  <script>
    const canvas = document.getElementById("mazeCanvas");
    const ctx = canvas.getContext("2d");
    let width, height;
    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener("resize", resize);
    resize();

    const CELL_SIZE = 20;
    const MAZE_ROWS = 21;
    const MAZE_COLS = 21;
    let maze = [];
    let player = { x: Math.floor(MAZE_COLS / 2), y: Math.floor(MAZE_ROWS / 2) };
    let steps = 0;
    let lastLat = null, lastLon = null;
    const stepThreshold = 0.00001; // ~1 metro según lat/lon, se ajusta en pruebas

    function generateMaze() {
      maze = Array.from({ length: MAZE_ROWS }, () =>
        Array.from({ length: MAZE_COLS }, () => ({ top: true, right: true, bottom: true, left: true, visited: false }))
      );

      function visit(x, y) {
        maze[y][x].visited = true;
        const dirs = ["top", "right", "bottom", "left"].sort(() => Math.random() - 0.5);
        for (const dir of dirs) {
          const nx = x + (dir === "left" ? -1 : dir === "right" ? 1 : 0);
          const ny = y + (dir === "top" ? -1 : dir === "bottom" ? 1 : 0);
          if (ny >= 0 && ny < MAZE_ROWS && nx >= 0 && nx < MAZE_COLS && !maze[ny][nx].visited) {
            maze[y][x][dir] = false;
            maze[ny][nx][{ top: "bottom", bottom: "top", left: "right", right: "left" }[dir]] = false;
            visit(nx, ny);
          }
        }
      }
      visit(Math.floor(MAZE_COLS / 2), Math.floor(MAZE_ROWS / 2));
    }

    function drawMaze() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.translate(width / 2 - player.x * CELL_SIZE, height / 2 - player.y * CELL_SIZE);
      ctx.lineWidth = 1;
      ctx.strokeStyle = "#fff";

      for (let y = 0; y < MAZE_ROWS; y++) {
        for (let x = 0; x < MAZE_COLS; x++) {
          const cell = maze[y][x];
          const px = x * CELL_SIZE;
          const py = y * CELL_SIZE;
          if (cell.top) {
            ctx.beginPath();
            ctx.moveTo(px, py);
            ctx.lineTo(px + CELL_SIZE, py);
            ctx.stroke();
          }
          if (cell.right) {
            ctx.beginPath();
            ctx.moveTo(px + CELL_SIZE, py);
            ctx.lineTo(px + CELL_SIZE, py + CELL_SIZE);
            ctx.stroke();
          }
          if (cell.bottom) {
            ctx.beginPath();
            ctx.moveTo(px + CELL_SIZE, py + CELL_SIZE);
            ctx.lineTo(px, py + CELL_SIZE);
            ctx.stroke();
          }
          if (cell.left) {
            ctx.beginPath();
            ctx.moveTo(px, py + CELL_SIZE);
            ctx.lineTo(px, py);
            ctx.stroke();
          }
        }
      }

      // Player
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(player.x * CELL_SIZE + CELL_SIZE / 2, player.y * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }

    function updateCoordsDisplay(lat, lon) {
      document.getElementById("coords").textContent = `Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}`;
    }

    function updateStepsDisplay() {
      document.getElementById("steps").textContent = `Pasos: ${steps}`;
    }

    function handleMovement(lat, lon) {
      if (lastLat === null || lastLon === null) {
        lastLat = lat;
        lastLon = lon;
        return;
      }

      const dLat = lat - lastLat;
      const dLon = lon - lastLon;

      let moved = false;

      if (Math.abs(dLat) > Math.abs(dLon)) {
        if (dLat < -stepThreshold && !maze[player.y][player.x].top) {
          player.y = Math.max(0, player.y - 1);
          moved = true;
        } else if (dLat > stepThreshold && !maze[player.y][player.x].bottom) {
          player.y = Math.min(MAZE_ROWS - 1, player.y + 1);
          moved = true;
        }
      } else {
        if (dLon > stepThreshold && !maze[player.y][player.x].right) {
          player.x = Math.min(MAZE_COLS - 1, player.x + 1);
          moved = true;
        } else if (dLon < -stepThreshold && !maze[player.y][player.x].left) {
          player.x = Math.max(0, player.x - 1);
          moved = true;
        }
      }

      if (moved) {
        steps++;
        lastLat = lat;
        lastLon = lon;
        updateStepsDisplay();
      }
    }

    function initGeolocation() {
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(
          pos => {
            const lat = pos.coords.latitude;
            const lon = pos.coords.longitude;
            updateCoordsDisplay(lat, lon);
            handleMovement(lat, lon);
          },
          err => {
            console.error("GPS error", err);
          },
          { enableHighAccuracy: true, maximumAge: 1000, timeout: 27000 }
        );
      } else {
        alert("Tu navegador no soporta geolocalización.");
      }
    }

    function initGyroscope() {
      if (window.DeviceOrientationEvent) {
        window.addEventListener("deviceorientation", function(event) {
          const alpha = event.alpha;
          canvas.style.transform = `rotate(${-alpha}deg)`;
        });
      }
    }

    function animate() {
      drawMaze();
      requestAnimationFrame(animate);
    }

    generateMaze();
    initGeolocation();
    initGyroscope();
    updateStepsDisplay();
    animate();
  </script>
</body>
</html>
