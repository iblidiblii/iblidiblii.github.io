<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Laberinto GPS</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      color: white;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      background: black;
    }
    #info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <canvas id="mazeCanvas"></canvas>
  <div id="info">
    <div>Pasos: <span id="stepCount">0</span></div>
    <div>Lat: <span id="lat">--</span></div>
    <div>Lon: <span id="lon">--</span></div>
  </div>

  <script>
    const canvas = document.getElementById("mazeCanvas");
    const ctx = canvas.getContext("2d");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    let cols = 21;
    let rows = 21;
    let cellSize = 40;

    const maze = [];
    const stack = [];

    class Cell {
      constructor(col, row) {
        this.col = col;
        this.row = row;
        this.walls = [true, true, true, true]; // top, right, bottom, left
        this.visited = false;
      }

      draw(ctx, offsetX, offsetY, scale) {
        const x = this.col * cellSize * scale - offsetX;
        const y = this.row * cellSize * scale - offsetY;

        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 2;

        if (this.walls[0]) drawLine(x, y, x + cellSize * scale, y); // top
        if (this.walls[1]) drawLine(x + cellSize * scale, y, x + cellSize * scale, y + cellSize * scale); // right
        if (this.walls[2]) drawLine(x + cellSize * scale, y + cellSize * scale, x, y + cellSize * scale); // bottom
        if (this.walls[3]) drawLine(x, y + cellSize * scale, x, y); // left
      }
    }

    function drawLine(x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function index(col, row) {
      if (col < 0 || row < 0 || col >= cols || row >= rows) return -1;
      return col + row * cols;
    }

    function generateMaze() {
      maze.length = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          maze.push(new Cell(c, r));
        }
      }

      let current = maze[0];
      current.visited = true;
      stack.push(current);

      while (stack.length > 0) {
        let next = getUnvisitedNeighbor(current);
        if (next) {
          next.visited = true;
          stack.push(current);
          removeWalls(current, next);
          current = next;
        } else {
          current = stack.pop();
        }
      }
    }

    function getUnvisitedNeighbor(cell) {
      const neighbors = [];
      const { col, row } = cell;

      const top = maze[index(col, row - 1)];
      const right = maze[index(col + 1, row)];
      const bottom = maze[index(col, row + 1)];
      const left = maze[index(col - 1, row)];

      if (top && !top.visited) neighbors.push(top);
      if (right && !right.visited) neighbors.push(right);
      if (bottom && !bottom.visited) neighbors.push(bottom);
      if (left && !left.visited) neighbors.push(left);

      if (neighbors.length > 0) {
        return neighbors[Math.floor(Math.random() * neighbors.length)];
      } else {
        return undefined;
      }
    }

    function removeWalls(a, b) {
      let dx = a.col - b.col;
      let dy = a.row - b.row;

      if (dx === 1) {
        a.walls[3] = false;
        b.walls[1] = false;
      } else if (dx === -1) {
        a.walls[1] = false;
        b.walls[3] = false;
      }

      if (dy === 1) {
        a.walls[0] = false;
        b.walls[2] = false;
      } else if (dy === -1) {
        a.walls[2] = false;
        b.walls[0] = false;
      }
    }

    let player = {
      x: Math.floor(cols / 2),
      y: Math.floor(rows / 2),
      steps: 0
    };

    function draw() {
      ctx.clearRect(0, 0, width, height);

      let scale = 2; // zoom
      let offsetX = (player.x + 0.5) * cellSize * scale - width / 2;
      let offsetY = (player.y + 0.5) * cellSize * scale - height / 2;

      maze.forEach(cell => cell.draw(ctx, offsetX, offsetY, scale));

      // Draw player
      let px = player.x * cellSize * scale - offsetX + cellSize * scale / 2;
      let py = player.y * cellSize * scale - offsetY + cellSize * scale / 2;

      ctx.beginPath();
      ctx.fillStyle = "red";
      ctx.arc(px, py, 10, 0, Math.PI * 2);
      ctx.fill();
    }

    function canMoveTo(x, y) {
      const current = maze[index(player.x, player.y)];
      if (!current) return false;

      let dir;
      if (x > player.x) dir = 1;
      else if (x < player.x) dir = 3;
      else if (y > player.y) dir = 2;
      else if (y < player.y) dir = 0;

      if (dir === undefined || current.walls[dir]) return false;

      return maze[index(x, y)];
    }

    function move(dx, dy) {
      let newX = player.x + dx;
      let newY = player.y + dy;

      if (canMoveTo(newX, newY)) {
        player.x = newX;
        player.y = newY;
        player.steps++;
        document.getElementById("stepCount").textContent = player.steps;
      }
    }

    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowUp") move(0, -1);
      if (e.key === "ArrowDown") move(0, 1);
      if (e.key === "ArrowLeft") move(-1, 0);
      if (e.key === "ArrowRight") move(1, 0);
    });

    // GPS Tracking
    let lastLat = null;
    let lastLon = null;

    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3; // m
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ/2) * Math.sin(Δλ/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

      return R * c;
    }

    function handlePosition(pos) {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;

      document.getElementById("lat").textContent = lat.toFixed(5);
      document.getElementById("lon").textContent = lon.toFixed(5);

      if (lastLat !== null && lastLon !== null) {
        const dist = getDistance(lastLat, lastLon, lat, lon);
        if (dist >= 1) {
          // Estimate direction
          let dx = lon - lastLon;
          let dy = lat - lastLat;

          if (Math.abs(dx) > Math.abs(dy)) {
            move(dx > 0 ? 1 : -1, 0);
          } else {
            move(0, dy > 0 ? 1 : -1);
          }

          lastLat = lat;
          lastLon = lon;
        }
      } else {
        lastLat = lat;
        lastLon = lon;
      }
    }

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(handlePosition, console.error, {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: 5000
      });
    }

    // Gyroscope
    window.addEventListener("deviceorientation", (e) => {
      const angle = e.alpha;
      canvas.style.transform = `rotate(${360 - angle}deg)`;
    });

    function loop() {
      draw();
      requestAnimationFrame(loop);
    }

    generateMaze();
    loop();
  </script>
</body>
</html>

