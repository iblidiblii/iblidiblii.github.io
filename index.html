<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Laberinto Descubrimiento</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
    #fade {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      background: black;
      pointer-events: none;
      opacity: 0;
      transition: opacity 3s;
    }
    #hint {
      position: absolute;
      top: 0; left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 2s;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="fade"></div>
<canvas id="hint"></canvas>
<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const fade = document.getElementById('fade');
  const hintCanvas = document.getElementById('hint');
  const hintCtx = hintCanvas.getContext('2d');
  let width, height;

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    hintCanvas.width = width;
    hintCanvas.height = height;
  }
  window.addEventListener('resize', resize);
  resize();

  const seed = Math.floor(Date.now() % 1000000);
  const rand = (() => {
    let x = seed;
    return () => {
      x ^= x << 13;
      x ^= x >> 17;
      x ^= x << 5;
      return Math.abs(x % 1000) / 1000;
    };
  })();

  const cols = 30, rows = 30;
  const cellSize = 40;
  let maze = [];
  let player = { x: Math.floor(cols / 2), y: Math.floor(rows / 2) };
  let exit = { x: 0, y: 0 };
  let lastHintTime = 0;

  function generateMaze() {
    maze = Array(rows).fill(0).map(() => Array(cols).fill({ top: true, right: true, bottom: true, left: true }));
    const visited = Array(rows).fill(0).map(() => Array(cols).fill(false));

    function carve(x, y) {
      visited[y][x] = true;
      const dirs = ['top', 'right', 'bottom', 'left'].sort(() => rand() - 0.5);
      for (let dir of dirs) {
        let nx = x, ny = y;
        if (dir === 'top') ny--;
        if (dir === 'right') nx++;
        if (dir === 'bottom') ny++;
        if (dir === 'left') nx--;

        if (nx >= 0 && ny >= 0 && nx < cols && ny < rows && !visited[ny][nx]) {
          maze[y][x] = { ...maze[y][x], [dir]: false };
          const opposite = { top: 'bottom', right: 'left', bottom: 'top', left: 'right' };
          maze[ny][nx] = { ...maze[ny][nx], [opposite[dir]]: false };
          carve(nx, ny);
        }
      }
    }

    carve(0, 0);

    // Fijamos la salida segÃºn semilla
    const corners = [
      { x: 0, y: 0 },
      { x: cols - 1, y: 0 },
      { x: 0, y: rows - 1 },
      { x: cols - 1, y: rows - 1 }
    ];
    exit = corners[Math.floor(rand() * 4)];
  }

  function drawMaze() {
    ctx.clearRect(0, 0, width, height);
    const cameraX = player.x * cellSize;
    const cameraY = player.y * cellSize;

    const offsetX = width / 2 - cameraX - cellSize / 2;
    const offsetY = height / 2 - cameraY - cellSize / 2;

    ctx.strokeStyle = "white";
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = maze[y][x];
        const cx = x * cellSize + offsetX;
        const cy = y * cellSize + offsetY;

        if (cell.top) ctx.strokeRect(cx, cy, cellSize, 1);
        if (cell.left) ctx.strokeRect(cx, cy, 1, cellSize);
        if (cell.right) ctx.strokeRect(cx + cellSize, cy, 1, cellSize);
        if (cell.bottom) ctx.strokeRect(cx, cy + cellSize, cellSize, 1);
      }
    }

    // Draw exit
    ctx.fillStyle = "lime";
    ctx.fillRect(exit.x * cellSize + offsetX + 10, exit.y * cellSize + offsetY + 10, cellSize - 20, cellSize - 20);

    // Draw player
    ctx.fillStyle = "cyan";
    ctx.beginPath();
    const px = player.x * cellSize + offsetX + cellSize / 2;
    const py = player.y * cellSize + offsetY + cellSize / 2;
    ctx.moveTo(px, py - 10);
    ctx.lineTo(px - 8, py + 8);
    ctx.lineTo(px + 8, py + 8);
    ctx.closePath();
    ctx.fill();
  }

  function movePlayer(dx, dy) {
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) return;
    const dir = dx === 1 ? "right" : dx === -1 ? "left" : dy === 1 ? "bottom" : "top";
    if (!maze[player.y][player.x][dir]) {
      player.x = nx;
      player.y = ny;
    }
  }

  canvas.addEventListener('click', (e) => {
    const x = e.clientX, y = e.clientY;
    if (y < height / 3) movePlayer(0, -1);
    else if (y > 2 * height / 3) movePlayer(0, 1);
    else if (x < width / 2) movePlayer(-1, 0);
    else movePlayer(1, 0);
  });

  function vibrate(duration) {
    if (navigator.vibrate) navigator.vibrate(duration);
  }

  function animateFade() {
    fade.style.opacity = 1;
    vibrate(3000);
    setTimeout(() => {
      generateMaze();
      fade.style.opacity = 0;
    }, 3000);
  }

  let startTime = Date.now();
  generateMaze();

  setInterval(() => {
    animateFade();
  }, 60000);

  setInterval(() => {
    const now = Date.now();
    if (now - startTime > 120000 && now - lastHintTime > 120000) {
      lastHintTime = now;
      const dx = exit.x - player.x;
      const dy = exit.y - player.y;
      const angle = Math.atan2(dy, dx);

      hintCtx.clearRect(0, 0, width, height);
      const grad = hintCtx.createRadialGradient(width / 2, height / 2, 0, width / 2 + Math.cos(angle) * 300, height / 2 + Math.sin(angle) * 300, 300);
      grad.addColorStop(0, "rgba(255,255,0,0.4)");
      grad.addColorStop(1, "rgba(255,255,0,0)");
      hintCtx.fillStyle = grad;
      hintCtx.fillRect(0, 0, width, height);
      document.getElementById('hint').style.opacity = 1;
      vibrate([200, 100, 200, 100, 200]);

      setTimeout(() => {
        document.getElementById('hint').style.opacity = 0;
      }, 4000);
    }
  }, 1000);

  function loop() {
    drawMaze();
    requestAnimationFrame(loop);
  }

  loop();
</script>
</body>
</html>
