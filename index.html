<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Laberinto dinámico</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="mazeCanvas"></canvas>
  <script>
    const canvas = document.getElementById("mazeCanvas");
    const ctx = canvas.getContext("2d");

    let cols = 25;
    let rows = 25;
    let cellSize;
    let maze = [];
    let visited = [];
    let stack = [];
    let transitionFrames = 48;
    let transitionCount = 0;
    let transitioning = false;
    let oldMaze = [];
    let steps = 0;
    let stepLimit = 15;

    // Jugador empieza en el centro
    let player = {
      x: Math.floor(cols / 2),
      y: Math.floor(rows / 2)
    };

    // Cámara centrada en jugador
    let camera = {
      x: 0,
      y: 0
    };

    let exitCell = {
      x: cols - 1,
      y: rows - 1
    };

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      cellSize = Math.floor(canvas.height / 15);
      updateCamera(); // Centrar cámara en jugador
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function createGrid() {
      maze = [];
      visited = [];
      for (let y = 0; y < rows; y++) {
        maze[y] = [];
        visited[y] = [];
        for (let x = 0; x < cols; x++) {
          maze[y][x] = [true, true, true, true]; // top, right, bottom, left
          visited[y][x] = false;
        }
      }
    }

    function generateMaze(cx, cy) {
      visited[cy][cx] = true;
      const directions = [
        [0, -1, 0], // top
        [1, 0, 1],  // right
        [0, 1, 2],  // bottom
        [-1, 0, 3]  // left
      ].sort(() => Math.random() - 0.5);

      for (const [dx, dy, dir] of directions) {
        const nx = cx + dx;
        const ny = cy + dy;
        if (nx >= 0 && ny >= 0 && nx < cols && ny < rows && !visited[ny][nx]) {
          maze[cy][cx][dir] = false;
          maze[ny][nx][(dir + 2) % 4] = false;
          generateMaze(nx, ny);
        }
      }
    }

    function drawMaze(interpolate = 1) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 1;

      ctx.save();
      ctx.translate(-camera.x, -camera.y);

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cx = x * cellSize;
          const cy = y * cellSize;

          const current = transitioning ? interpolateMazeCell(x, y, interpolate) : maze[y][x];

          ctx.beginPath();
          if (current[0]) ctx.moveTo(cx, cy), ctx.lineTo(cx + cellSize, cy); // top
          if (current[1]) ctx.moveTo(cx + cellSize, cy), ctx.lineTo(cx + cellSize, cy + cellSize); // right
          if (current[2]) ctx.moveTo(cx + cellSize, cy + cellSize), ctx.lineTo(cx, cy + cellSize); // bottom
          if (current[3]) ctx.moveTo(cx, cy + cellSize), ctx.lineTo(cx, cy); // left
          ctx.stroke();
        }
      }

      // Dibujar jugador
      ctx.fillStyle = "#00FFFF";
      ctx.beginPath();
      ctx.arc(
        player.x * cellSize + cellSize / 2,
        player.y * cellSize + cellSize / 2,
        cellSize / 4,
        0,
        Math.PI * 2
      );
      ctx.fill();

      // Dibujar salida
      ctx.fillStyle = "lime";
      ctx.beginPath();
      ctx.arc(
        exitCell.x * cellSize + cellSize / 2,
        exitCell.y * cellSize + cellSize / 2,
        cellSize / 5,
        0,
        Math.PI * 2
      );
      ctx.fill();

      ctx.restore();
    }

    function interpolateMazeCell(x, y, t) {
      const oldCell = oldMaze[y][x];
      const newCell = maze[y][x];
      return newCell.map((wall, i) => (t < 0.5 ? oldCell[i] : wall));
    }

    function updateCamera() {
      camera.x += ((player.x * cellSize + cellSize / 2) - canvas.width / 2 - camera.x) * 0.1;
      camera.y += ((player.y * cellSize + cellSize / 2) - canvas.height / 2 - camera.y) * 0.1;
    }

    function handleInput(event) {
      if (transitioning) return;
      const key = event.key;
      let dx = 0, dy = 0;
      if (key === "ArrowUp") dy = -1;
      if (key === "ArrowDown") dy = 1;
      if (key === "ArrowLeft") dx = -1;
      if (key === "ArrowRight") dx = 1;

      const nx = player.x + dx;
      const ny = player.y + dy;

      if (nx >= 0 && ny >= 0 && nx < cols && ny < rows) {
        const dir = dx === 1 ? 1 : dx === -1 ? 3 : dy === 1 ? 2 : 0;
        if (!maze[player.y][player.x][dir]) {
          player.x = nx;
          player.y = ny;
          steps++;
          if (steps >= stepLimit) {
            steps = 0;
            startMazeTransition();
          }
        }
      }
    }

    function startMazeTransition() {
      transitioning = true;
      transitionCount = 0;
      oldMaze = maze.map(row => row.map(cell => [...cell]));
      createGrid();
      generateMaze(Math.floor(cols / 2), Math.floor(rows / 2));
    }

    function animate() {
      requestAnimationFrame(animate);

      if (transitioning) {
        transitionCount++;
        const t = transitionCount / transitionFrames;
        drawMaze(t);
        if (transitionCount >= transitionFrames) {
          transitioning = false;
        }
      } else {
        drawMaze();
      }

      updateCamera();
    }

    document.addEventListener("keydown", handleInput);

    // Iniciar
    createGrid();
    generateMaze(Math.floor(cols / 2), Math.floor(rows / 2));
    animate();
  </script>
</body>
</html>
