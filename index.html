<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Laberinto GPS</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      font-family: sans-serif;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 6px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="info">Lat: -, Lon: -<br>Pasos: 0</div>
  <canvas id="gameCanvas"></canvas>


  <script>
  const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

let cols = 21, rows = 21;
let maze = [];
let cellSize = 40;

let player = {
  x: Math.floor(cols / 2),
  y: Math.floor(rows / 2),
  angle: 0,
  lat: null,
  lon: null,
  lastLat: null,
  lastLon: null,
  steps: 0
};

let orientation = 0;

// Aproximación de distancia por grado
const metersPerDegreeLat = 111320;
const metersPerDegreeLon = 40075000 * Math.cos(player.lat || 0) / 360;

// Generar laberinto vacío
function generateMaze() {
  maze = Array(rows).fill().map(() => Array(cols).fill({ top: true, right: true, bottom: true, left: true }));

  // Quitar paredes simples para crear caminos (demo)
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (x < cols - 1) maze[y][x].right = false;
      if (y < rows - 1) maze[y][x].bottom = false;
    }
  }
}

function drawMaze() {
  ctx.save();
  ctx.clearRect(0, 0, width, height);

  const visibleCols = Math.floor(width / cellSize);
  const visibleRows = Math.floor(height / cellSize);

  const offsetX = width / 2 - player.x * cellSize - cellSize / 2;
  const offsetY = height / 2 - player.y * cellSize - cellSize / 2;

  ctx.translate(offsetX, offsetY);

  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const cell = maze[y][x];
      const px = x * cellSize;
      const py = y * cellSize;

      if (cell.top) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + cellSize, py);
        ctx.stroke();
      }
      if (cell.right) {
        ctx.beginPath();
        ctx.moveTo(px + cellSize, py);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.bottom) {
        ctx.beginPath();
        ctx.moveTo(px, py + cellSize);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.left) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px, py + cellSize);
        ctx.stroke();
      }
    }
  }

  // Dibujar punto de salida (esquina inferior derecha)
  ctx.fillStyle = "green";
  ctx.fillRect((cols - 1) * cellSize + 10, (rows - 1) * cellSize + 10, 20, 20);

  // Dibujar jugador como triángulo
  ctx.translate(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
  ctx.rotate((orientation * Math.PI) / 180);

  ctx.beginPath();
  ctx.moveTo(0, -cellSize / 2); // punta hacia arriba
  ctx.lineTo(cellSize / 3, cellSize / 3);
  ctx.lineTo(-cellSize / 3, cellSize / 3);
  ctx.closePath();
  ctx.fillStyle = "red";
  ctx.fill();

  ctx.restore();
}

function canMoveTo(nx, ny) {
  if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) return false;

  let dx = nx - player.x;
  let dy = ny - player.y;
  const cell = maze[player.y][player.x];

  if (dx === 1 && cell.right) return false;
  if (dx === -1 && cell.left) return false;
  if (dy === 1 && cell.bottom) return false;
  if (dy === -1 && cell.top) return false;

  return true;
}

function moveForward() {
  let angle = orientation % 360;
  if (angle < 0) angle += 360;

  let dir = [0, 0];
  if (angle >= 45 && angle < 135) dir = [1, 0]; // derecha
  else if (angle >= 135 && angle < 225) dir = [0, 1]; // abajo
  else if (angle >= 225 && angle < 315) dir = [-1, 0]; // izquierda
  else dir = [0, -1]; // arriba

  let nx = player.x + dir[0];
  let ny = player.y + dir[1];

  if (canMoveTo(nx, ny)) {
    player.x = nx;
    player.y = ny;
    player.steps++;
  }
}

function updatePosition(lat, lon) {
  if (player.lat !== null && player.lon !== null) {
    const dx = (lon - player.lon) * metersPerDegreeLat;
    const dy = (lat - player.lat) * metersPerDegreeLon;
    const distance = Math.sqrt(dx * dx + dy * dy);

    const angleRad = (orientation * Math.PI) / 180;
    const forwardX = Math.cos(angleRad);
    const forwardY = Math.sin(angleRad);
    const dot = (dx * forwardX + dy * forwardY) / Math.sqrt(dx * dx + dy * dy);

    if (distance >= 0.2 && dot > 0.7) {
      moveForward();
    }
  }

  player.lat = lat;
  player.lon = lon;

  document.getElementById("info").innerHTML =
    `Lat: ${lat.toFixed(6)}, Lon: ${lon.toFixed(6)}<br>Pasos: ${player.steps}`;
}

navigator.geolocation.watchPosition(
  pos => updatePosition(pos.coords.latitude, pos.coords.longitude),
  err => console.error(err),
  { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 }
);

window.addEventListener("deviceorientation", e => {
  orientation = 360 - e.alpha;
});

function loop() {
  drawMaze();
  requestAnimationFrame(loop);
}

generateMaze();
loop();
    
        
      
  </script>
</body>
</html>
