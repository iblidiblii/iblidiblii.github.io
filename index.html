<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Labertinto GPS</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let cellSize = 32;
  let cols, rows;
  let maze = [];
  let current;
  let player = { x: 0, y: 0 };
  let mazeOffsetX = 0, mazeOffsetY = 0;

  const directions = {
    'N': [0, -1],
    'S': [0, 1],
    'E': [1, 0],
    'W': [-1, 0]
  };

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  class Cell {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.walls = { N: true, S: true, E: true, W: true };
      this.visited = false;
    }

    draw() {
      const px = this.x * cellSize - mazeOffsetX;
      const py = this.y * cellSize - mazeOffsetY;

      ctx.strokeStyle = 'white';
      ctx.lineWidth = 1;

      if (this.walls.N) drawLine(px, py, px + cellSize, py);
      if (this.walls.E) drawLine(px + cellSize, py, px + cellSize, py + cellSize);
      if (this.walls.S) drawLine(px, py + cellSize, px + cellSize, py + cellSize);
      if (this.walls.W) drawLine(px, py, px, py + cellSize);
    }
  }

  function drawLine(x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  function index(x, y) {
    if (x < 0 || y < 0 || x >= cols || y >= rows) return null;
    return x + y * cols;
  }

  function getNeighbours(cell) {
    const neighbours = [];

    for (const [dir, [dx, dy]] of Object.entries(directions)) {
      const nx = cell.x + dx;
      const ny = cell.y + dy;
      const neighbor = maze[index(nx, ny)];
      if (neighbor && !neighbor.visited) {
        neighbours.push({ cell: neighbor, direction: dir });
      }
    }

    return neighbours;
  }

  function removeWalls(a, b, dir) {
    const opposite = { N: 'S', S: 'N', E: 'W', W: 'E' };
    a.walls[dir] = false;
    b.walls[opposite[dir]] = false;
  }

  function generateMaze() {
    cols = Math.floor(window.innerWidth / cellSize) * 2;
    rows = Math.floor(window.innerHeight / cellSize) * 2;

    maze = [];
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        maze.push(new Cell(x, y));
      }
    }

    current = maze[0];
    let stack = [];

    current.visited = true;

    while (true) {
      const neighbours = getNeighbours(current);

      if (neighbours.length > 0) {
        const { cell: next, direction } = neighbours[Math.floor(Math.random() * neighbours.length)];
        stack.push(current);
        removeWalls(current, next, direction);
        current = next;
        current.visited = true;
      } else if (stack.length > 0) {
        current = stack.pop();
      } else {
        break;
      }
    }

    // Centrar al jugador
    player.x = Math.floor(cols / 2);
    player.y = Math.floor(rows / 2);
  }

  function drawMaze() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    maze.forEach(cell => cell.draw());

    // Jugador
    const px = player.x * cellSize - mazeOffsetX;
    const py = player.y * cellSize - mazeOffsetY;
    ctx.fillStyle = 'cyan';
    ctx.beginPath();
    ctx.arc(px + cellSize / 2, py + cellSize / 2, cellSize / 4, 0, 2 * Math.PI);
    ctx.fill();
  }

  function updateCamera() {
    mazeOffsetX = player.x * cellSize - canvas.width / 2 + cellSize / 2;
    mazeOffsetY = player.y * cellSize - canvas.height / 2 + cellSize / 2;
  }

  function canMoveTo(x, y) {
    if (x < 0 || y < 0 || x >= cols || y >= rows) return false;

    const from = maze[index(player.x, player.y)];
    const to = maze[index(x, y)];

    for (const [dir, [dx, dy]] of Object.entries(directions)) {
      if (player.x + dx === x && player.y + dy === y) {
        if (!from.walls[dir]) return true;
      }
    }

    return false;
  }

  function tryMove(dx, dy) {
    const nx = player.x + dx;
    const ny = player.y + dy;
    if (canMoveTo(nx, ny)) {
      player.x = nx;
      player.y = ny;
      updateCamera();
    }
  }

  // GPS
  let lastPos = null;

  function handlePosition(pos) {
    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;

    if (lastPos) {
      const dx = lon - lastPos.lon;
      const dy = lat - lastPos.lat;

      const threshold = 0.00003;

      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > threshold) tryMove(1, 0);
        else if (dx < -threshold) tryMove(-1, 0);
      } else {
        if (dy > threshold) tryMove(0, -1);
        else if (dy < -threshold) tryMove(0, 1);
      }
    }

    lastPos = { lat, lon };
  }

  function handleError(err) {
    console.warn(`ERROR(${err.code}): ${err.message}`);
  }

  navigator.geolocation.watchPosition(handlePosition, handleError, {
    enableHighAccuracy: true,
    maximumAge: 1000,
    timeout: 5000
  });

  generateMaze();
  updateCamera();

  function animate() {
    drawMaze();
    requestAnimationFrame(animate);
  }

  animate();
</script>
</body>
</html>
