<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Laberinto por Toques</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      touch-action: manipulation;
    }
    canvas {
      display: block;
    }
    #fade {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      pointer-events: none;
      opacity: 0;
      transition: opacity 3s;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="fade"></div>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const cols = 40;
    const rows = 40;
    const cellSize = 40;

    let maze = [];
    let player = { x: Math.floor(cols / 2), y: Math.floor(rows / 2) };
    let exit = { x: 0, y: 0 };
    const seed = Date.now();

    function seededRandom(seed) {
      return function() {
        seed = Math.sin(seed) * 10000;
        return seed - Math.floor(seed);
      };
    }

    const rand = seededRandom(seed);

    function generateMaze() {
      maze = Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => ({ top: true, right: true, bottom: true, left: true, visited: false }))
      );

      const stack = [];
      let current = { x: Math.floor(rand() * cols), y: Math.floor(rand() * rows) };

      function getNeighbors(x, y) {
        const neighbors = [];
        if (y > 0 && !maze[y - 1][x].visited) neighbors.push({ x: x, y: y - 1, dir: "top" });
        if (x < cols - 1 && !maze[y][x + 1].visited) neighbors.push({ x: x + 1, y: y, dir: "right" });
        if (y < rows - 1 && !maze[y + 1][x].visited) neighbors.push({ x: x, y: y + 1, dir: "bottom" });
        if (x > 0 && !maze[y][x - 1].visited) neighbors.push({ x: x - 1, y: y, dir: "left" });
        return neighbors;
      }

      function removeWall(a, b, dir) {
        if (dir === "top") {
          maze[a.y][a.x].top = false;
          maze[b.y][b.x].bottom = false;
        } else if (dir === "right") {
          maze[a.y][a.x].right = false;
          maze[b.y][b.x].left = false;
        } else if (dir === "bottom") {
          maze[a.y][a.x].bottom = false;
          maze[b.y][b.x].top = false;
        } else if (dir === "left") {
          maze[a.y][a.x].left = false;
          maze[b.y][b.x].right = false;
        }
      }

      do {
        maze[current.y][current.x].visited = true;
        const neighbors = getNeighbors(current.x, current.y);
        if (neighbors.length > 0) {
          const next = neighbors[Math.floor(rand() * neighbors.length)];
          stack.push(current);
          removeWall(current, next, next.dir);
          current = { x: next.x, y: next.y };
        } else {
          current = stack.pop();
        }
      } while (stack.length > 0);
    }

    function drawMaze() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const viewSize = Math.floor(Math.min(width, height) / cellSize / 2);
      const offsetX = player.x - viewSize;
      const offsetY = player.y - viewSize;

      for (let y = Math.max(0, offsetY); y < Math.min(rows, player.y + viewSize); y++) {
        for (let x = Math.max(0, offsetX); x < Math.min(cols, player.x + viewSize); x++) {
          const cell = maze[y][x];
          const sx = (x - offsetX) * cellSize;
          const sy = (y - offsetY) * cellSize;

          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          if (cell.top) {
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx + cellSize, sy);
            ctx.stroke();
          }
          if (cell.right) {
            ctx.beginPath();
            ctx.moveTo(sx + cellSize, sy);
            ctx.lineTo(sx + cellSize, sy + cellSize);
            ctx.stroke();
          }
          if (cell.bottom) {
            ctx.beginPath();
            ctx.moveTo(sx, sy + cellSize);
            ctx.lineTo(sx + cellSize, sy + cellSize);
            ctx.stroke();
          }
          if (cell.left) {
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx, sy + cellSize);
            ctx.stroke();
          }

          // Exit
          if (x === exit.x && y === exit.y) {
            ctx.fillStyle = "green";
            ctx.fillRect(sx + 10, sy + 10, cellSize - 20, cellSize - 20);
          }
        }
      }

      // Player
      const px = (player.x - offsetX) * cellSize + cellSize / 2;
      const py = (player.y - offsetY) * cellSize + cellSize / 2;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(px, py, cellSize / 4, 0, 2 * Math.PI);
      ctx.fill();
    }

    function canMove(x, y) {
      return x >= 0 && x < cols && y >= 0 && y < rows;
    }

    function movePlayer(dx, dy) {
      const cx = player.x;
      const cy = player.y;

      if (dx === 1 && !maze[cy][cx].right) player.x++;
      else if (dx === -1 && !maze[cy][cx].left) player.x--;
      else if (dy === 1 && !maze[cy][cx].bottom) player.y++;
      else if (dy === -1 && !maze[cy][cx].top) player.y--;

      drawMaze();
    }

    function handleClick(event) {
      const x = event.clientX;
      const y = event.clientY;

      if (y < height / 3) movePlayer(0, -1);
      else if (y > (2 * height) / 3) movePlayer(0, 1);
      else if (x < width / 2) movePlayer(-1, 0);
      else movePlayer(1, 0);
    }

    function fadeTransition(callback) {
      const fade = document.getElementById("fade");
      fade.style.opacity = 1;
      navigator.vibrate(3000);
      setTimeout(() => {
        callback();
        fade.style.opacity = 0;
      }, 3000);
    }

    function regenerateMaze() {
      fadeTransition(() => {
        generateMaze();
        drawMaze();
      });
    }

    canvas.addEventListener("click", handleClick);

    // Establecer la esquina de la salida seg√∫n semilla
    const exitCorner = Math.floor(rand() * 4);
    if (exitCorner === 0) exit = { x: 0, y: 0 };
    else if (exitCorner === 1) exit = { x: cols - 1, y: 0 };
    else if (exitCorner === 2) exit = { x: 0, y: rows - 1 };
    else exit = { x: cols - 1, y: rows - 1 };

    generateMaze();
    drawMaze();

    setInterval(regenerateMaze, 60000);
  </script>
</body>
</html>
