<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Laberinto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: white;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let cellSize = 40; // Distancia de la cámara (cuanto más grande, más lejos se ve)
let cols = 31;
let rows = 31;
let maze = [];
let visited = [];
let stack = [];

let player = { x: 0, y: 0, angle: 0 };
let exit = { x: 0, y: 0 };

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Inicializar laberinto vacío
function initMaze() {
  maze = [];
  visited = [];
  for (let y = 0; y < rows; y++) {
    maze[y] = [];
    visited[y] = [];
    for (let x = 0; x < cols; x++) {
      maze[y][x] = { top: true, right: true, bottom: true, left: true };
      visited[y][x] = false;
    }
  }
  generateMaze(1, 1);
}

function generateMaze(cx, cy) {
  visited[cy][cx] = true;
  const dirs = shuffle(["top", "right", "bottom", "left"]);
  for (let dir of dirs) {
    let nx = cx, ny = cy;
    if (dir === "top") ny--;
    else if (dir === "right") nx++;
    else if (dir === "bottom") ny++;
    else if (dir === "left") nx--;

    if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && !visited[ny][nx]) {
      maze[cy][cx][dir] = false;
      if (dir === "top") maze[ny][nx]["bottom"] = false;
      if (dir === "right") maze[ny][nx]["left"] = false;
      if (dir === "bottom") maze[ny][nx]["top"] = false;
      if (dir === "left") maze[ny][nx]["right"] = false;
      generateMaze(nx, ny);
    }
  }
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function drawMaze() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  let offsetX = canvas.width / 2 - player.x * cellSize - cellSize / 2;
  let offsetY = canvas.height / 2 - player.y * cellSize - cellSize / 2;

  ctx.strokeStyle = "#000";
  ctx.lineWidth = 1;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      let cell = maze[y][x];
      let px = x * cellSize + offsetX;
      let py = y * cellSize + offsetY;

      if (cell.top) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + cellSize, py);
        ctx.stroke();
      }
      if (cell.right) {
        ctx.beginPath();
        ctx.moveTo(px + cellSize, py);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.bottom) {
        ctx.beginPath();
        ctx.moveTo(px, py + cellSize);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.left) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px, py + cellSize);
        ctx.stroke();
      }
    }
  }

  // Salida
  ctx.fillStyle = "green";
  ctx.beginPath();
  ctx.arc(exit.x * cellSize + cellSize / 2 + offsetX, exit.y * cellSize + cellSize / 2 + offsetY, 6, 0, 2 * Math.PI);
  ctx.fill();

  // Jugador
  ctx.save();
  ctx.translate(player.x * cellSize + cellSize / 2 + offsetX, player.y * cellSize + cellSize / 2 + offsetY);
  ctx.rotate(player.angle);
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.moveTo(0, -10);
  ctx.lineTo(7, 7);
  ctx.lineTo(-7, 7);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function canMove(x, y, dir) {
  if (x < 0 || x >= cols || y < 0 || y >= rows) return false;
  let cell = maze[y][x];
  if (dir === "up") return !cell.top;
  if (dir === "down") return !cell.bottom;
  if (dir === "left") return !cell.left;
  if (dir === "right") return !cell.right;
  return false;
}

function advance(direction) {
  let dx = 0, dy = 0, angle = 0;
  if (direction === "up") { dy = -1; angle = 0; }
  if (direction === "down") { dy = 1; angle = Math.PI; }
  if (direction === "left") { dx = -1; angle = -Math.PI / 2; }
  if (direction === "right") { dx = 1; angle = Math.PI / 2; }

  player.angle = angle;

  let nx = player.x;
  let ny = player.y;

  while (canMove(nx, ny, direction)) {
    nx += dx;
    ny += dy;
    if ((direction === "up" || direction === "down") && (!canMove(nx, ny, "left") && !canMove(nx, ny, "right"))) break;
    if ((direction === "left" || direction === "right") && (!canMove(nx, ny, "up") && !canMove(nx, ny, "down"))) break;
  }

  player.x = nx;
  player.y = ny;
  drawMaze();
}

canvas.addEventListener("click", (e) => {
  const x = e.clientX;
  const y = e.clientY;
  const w = canvas.width;
  const h = canvas.height;

  if (y < h / 3) advance("up");
  else if (y > h * 2 / 3) advance("down");
  else if (x < w / 2) advance("left");
  else advance("right");
});

// Iniciar todo
function startGame() {
  initMaze();
  player.x = Math.floor(cols / 2);
  player.y = Math.floor(rows / 2);

  // Fijar salida en una esquina con semilla basada en hora
  const seed = new Date().getMilliseconds() % 4;
  if (seed === 0) exit = { x: 0, y: 0 };
  if (seed === 1) exit = { x: cols - 1, y: 0 };
  if (seed === 2) exit = { x: 0, y: rows - 1 };
  if (seed === 3) exit = { x: cols - 1, y: rows - 1 };

  drawMaze();
}

startGame();
</script>
</body>
</html>
