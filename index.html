<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Laberinto Descubrimiento</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let width, height;
function resize() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
}
window.addEventListener("resize", resize);
resize();

const cols = 41;
const rows = 41;
const cellSize = 20;
let maze = [];
let seed = Date.now();
let exitCorner;
let showGradient = false;
let showFade = false;

let player = {
  x: Math.floor(cols / 2),
  y: Math.floor(rows / 2),
  angle: 0,
  targetAngle: 0,
  screenX: 0,
  screenY: 0
};

let camera = {
  x: player.x,
  y: player.y
};

let fadeOpacity = 0;
let steps = 0;
let lastStepTime = Date.now();
let lastMazeUpdate = Date.now();
let lastHintTime = Date.now();

function seededRandom(seed) {
  return function() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };
}

function generateMaze(seed) {
  let rand = seededRandom(seed);
  let stack = [];
  maze = Array.from({length: rows}, () => Array(cols).fill(1));

  function visit(x, y) {
    maze[y][x] = 0;
    stack.push([x, y]);
    while (stack.length) {
      let [cx, cy] = stack[stack.length - 1];
      let dirs = [[0,-2],[2,0],[0,2],[-2,0]].sort(() => rand() - 0.5);
      let moved = false;
      for (let [dx, dy] of dirs) {
        let nx = cx + dx, ny = cy + dy;
        if (nx > 0 && ny > 0 && nx < cols-1 && ny < rows-1 && maze[ny][nx] === 1) {
          maze[cy + dy/2][cx + dx/2] = 0;
          maze[ny][nx] = 0;
          stack.push([nx, ny]);
          moved = true;
          break;
        }
      }
      if (!moved) stack.pop();
    }
  }

  visit(Math.floor(cols/2), Math.floor(rows/2));

  const corners = [[1,1],[cols-2,1],[1,rows-2],[cols-2,rows-2]];
  exitCorner = corners[Math.floor(rand()*corners.length)];
}

generateMaze(seed);

function drawMaze() {
  ctx.clearRect(0,0,width,height);
  ctx.save();
  const scale = Math.min(width, height) / 10;
  ctx.translate(width / 2, height / 2);
  ctx.translate(-(camera.x + 0.5) * scale, -(camera.y + 0.5) * scale);

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      if (maze[y][x] === 1) {
        ctx.fillStyle = "#222";
        ctx.fillRect(x * scale, y * scale, scale, scale);
      }
    }
  }

  // Salida
  ctx.fillStyle = "green";
  ctx.fillRect(exitCorner[0]*scale, exitCorner[1]*scale, scale, scale);

  // Pista
  if (showGradient) {
    const grad = ctx.createRadialGradient(
      player.x * scale, player.y * scale, scale,
      exitCorner[0]*scale, exitCorner[1]*scale, scale*15
    );
    grad.addColorStop(0, "rgba(0,255,0,0.15)");
    grad.addColorStop(1, "transparent");
    ctx.fillStyle = grad;
    ctx.fillRect((player.x - 5)*scale, (player.y - 5)*scale, scale*10, scale*10);
  }

  // Jugador
  ctx.translate((player.x + 0.5)*scale, (player.y + 0.5)*scale);
  ctx.rotate(player.angle);
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.moveTo(0, -scale * 0.5);
  ctx.lineTo(-scale * 0.3, scale * 0.3);
  ctx.lineTo(scale * 0.3, scale * 0.3);
  ctx.closePath();
  ctx.fill();

  ctx.restore();

  if (showFade) {
    ctx.fillStyle = `rgba(0,0,0,${fadeOpacity})`;
    ctx.fillRect(0, 0, width, height);
  }
}

function canMove(x, y) {
  return x >= 0 && y >= 0 && x < cols && y < rows && maze[y][x] === 0;
}

function move(dx, dy) {
  const nx = player.x + dx;
  const ny = player.y + dy;
  if (canMove(nx, ny)) {
    player.x = nx;
    player.y = ny;
    steps++;
    camera.targetX = player.x;
    camera.targetY = player.y;
    lastStepTime = Date.now();
  }
}

function smoothCamera() {
  camera.x += (player.x - camera.x) * 0.1;
  camera.y += (player.y - camera.y) * 0.1;
  player.angle += (player.targetAngle - player.angle) * 0.15;
}

canvas.addEventListener("click", e => {
  const x = e.clientX;
  const y = e.clientY;
  const centerX = width / 2;
  const centerY = height / 2;

  const dx = x - centerX;
  const dy = y - centerY;

  let dir;
  if (Math.abs(dx) > Math.abs(dy)) {
    dir = dx < 0 ? "left" : "right";
  } else {
    dir = dy < 0 ? "up" : "down";
  }

  let dxm = 0, dym = 0;
  if (dir === "up") dym = -1;
  if (dir === "down") dym = 1;
  if (dir === "left") dxm = -1;
  if (dir === "right") dxm = 1;

  const angleMap = {
    "up": 0,
    "right": Math.PI/2,
    "down": Math.PI,
    "left": -Math.PI/2
  };
  player.targetAngle = angleMap[dir];
  move(dxm, dym);
});

function vibrate(duration) {
  if (navigator.vibrate) navigator.vibrate(duration);
}

function updateTimers() {
  const now = Date.now();
  if (now - lastMazeUpdate > 60000) {
    seed = Date.now();
    generateMaze(seed);
    lastMazeUpdate = now;
    fadeOpacity = 1;
    showFade = true;
    vibrate(3000);
    setTimeout(() => {
      showFade = false;
    }, 3000);
  }

  if (now - lastHintTime > 120000) {
    showGradient = true;
    vibrate([200,100,200,100,200]);
    setTimeout(() => showGradient = false, 3000);
    lastHintTime = now;
  }
}

function drawOverlay() {
  ctx.fillStyle = "#0f0";
  ctx.font = "16px sans-serif";
  ctx.fillText(`Pasos: ${steps}`, 10, 20);
  ctx.fillText(`Posici√≥n: (${player.x}, ${player.y})`, 10, 40);
}

function loop() {
  smoothCamera();
  updateTimers();
  drawMaze();
  drawOverlay();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
