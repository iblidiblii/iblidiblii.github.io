<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Laberinto Scroll</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="mazeCanvas"></canvas>

<script>
const canvas = document.getElementById("mazeCanvas");
const ctx = canvas.getContext("2d");

let cols = 31;
let rows = 31;
let cellSize;
let maze = [];
let previousMaze = [];
let animationFrame = 0;
const maxAnimationFrames = 48;
let changing = false;
let stepCount = 0;
let maxSteps = 15;
let player = { x: Math.floor(cols / 2), y: Math.floor(rows / 2) };
let exitCell = { x: cols - 1, y: rows - 1 };

// Tamaño visible del laberinto
let viewCols = 15;
let viewRows = 15;

window.addEventListener("resize", resizeCanvas);
resizeCanvas();

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  cellSize = Math.floor(Math.min(canvas.width / viewCols, canvas.height / viewRows));
  drawMaze();
}

function generateMaze() {
  const maze = Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => ({ top: true, right: true, bottom: true, left: true, visited: false }))
  );

  const stack = [];
  let current = { x: 0, y: 0 };
  maze[current.y][current.x].visited = true;

  while (true) {
    const neighbors = [];

    const directions = [
      { dx: 0, dy: -1, dir: "top", opp: "bottom" },
      { dx: 1, dy: 0, dir: "right", opp: "left" },
      { dx: 0, dy: 1, dir: "bottom", opp: "top" },
      { dx: -1, dy: 0, dir: "left", opp: "right" },
    ];

    for (const { dx, dy, dir, opp } of directions) {
      const nx = current.x + dx;
      const ny = current.y + dy;
      if (
        nx >= 0 && nx < cols &&
        ny >= 0 && ny < rows &&
        !maze[ny][nx].visited
      ) {
        neighbors.push({ x: nx, y: ny, dir, opp });
      }
    }

    if (neighbors.length > 0) {
      const { x, y, dir, opp } = neighbors[Math.floor(Math.random() * neighbors.length)];
      maze[current.y][current.x][dir] = false;
      maze[y][x][opp] = false;
      stack.push(current);
      current = { x, y };
      maze[y][x].visited = true;
    } else if (stack.length > 0) {
      current = stack.pop();
    } else {
      break;
    }
  }

  // Salida en la esquina inferior derecha
  maze[exitCell.y][exitCell.x].bottom = false;
  return maze;
}

function drawMaze(alpha = 1.0) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
  ctx.lineWidth = 1;

  // Desplazamiento para centrar al jugador
  let offsetX = player.x - Math.floor(viewCols / 2);
  let offsetY = player.y - Math.floor(viewRows / 2);

  offsetX = Math.max(0, Math.min(offsetX, cols - viewCols));
  offsetY = Math.max(0, Math.min(offsetY, rows - viewRows));

  for (let y = 0; y < viewRows; y++) {
    for (let x = 0; x < viewCols; x++) {
      const cellX = x + offsetX;
      const cellY = y + offsetY;
      const cell = maze[cellY]?.[cellX];
      if (!cell) continue;

      const px = x * cellSize;
      const py = y * cellSize;

      ctx.beginPath();
      if (cell.top) {
        ctx.moveTo(px, py);
        ctx.lineTo(px + cellSize, py);
      }
      if (cell.right) {
        ctx.moveTo(px + cellSize, py);
        ctx.lineTo(px + cellSize, py + cellSize);
      }
      if (cell.bottom) {
        ctx.moveTo(px, py + cellSize);
        ctx.lineTo(px + cellSize, py + cellSize);
      }
      if (cell.left) {
        ctx.moveTo(px, py);
        ctx.lineTo(px, py + cellSize);
      }
      ctx.stroke();
    }
  }

  // Jugador
  const px = (player.x - offsetX) * cellSize + cellSize / 2;
  const py = (player.y - offsetY) * cellSize + cellSize / 2;
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.arc(px, py, cellSize / 4, 0, Math.PI * 2);
  ctx.fill();

  // Salida
  const ex = (exitCell.x - offsetX) * cellSize + cellSize / 2;
  const ey = (exitCell.y - offsetY) * cellSize + cellSize / 2;
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(ex, ey, cellSize / 6, 0, Math.PI * 2);
  ctx.fill();
}

function animate() {
  if (changing && animationFrame < maxAnimationFrames) {
    const t = animationFrame / maxAnimationFrames;
    drawMaze(1 - t); // fade out
    animationFrame++;
    requestAnimationFrame(animate);
  } else if (changing) {
    changing = false;
    animationFrame = 0;
    drawMaze(0);
    requestAnimationFrame(animateMazeIn);
  } else {
    drawMaze();
  }
}

function animateMazeIn() {
  if (animationFrame < maxAnimationFrames) {
    const t = animationFrame / maxAnimationFrames;
    drawMaze(t); // fade in
    animationFrame++;
    requestAnimationFrame(animateMazeIn);
  } else {
    drawMaze();
  }
}

function animateMazeTransition() {
  changing = true;

  const prevPlayerPos = { ...player };

  previousMaze = maze;
  maze = generateMaze();

  // Restaurar posición anterior
  if (
    prevPlayerPos.x >= 0 && prevPlayerPos.x < cols &&
    prevPlayerPos.y >= 0 && prevPlayerPos.y < rows
  ) {
    player = prevPlayerPos;
  }

  animationFrame = 0;
  animate();
}

function canMoveTo(x, y) {
  if (x < 0 || y < 0 || x >= cols || y >= rows) return false;
  return true;
}

function movePlayer(dx, dy) {
  if (changing) return;

  const cell = maze[player.y][player.x];
  if (
    (dx === -1 && !cell.left) ||
    (dx === 1 && !cell.right) ||
    (dy === -1 && !cell.top) ||
    (dy === 1 && !cell.bottom)
  ) {
    const newX = player.x + dx;
    const newY = player.y + dy;

    if (canMoveTo(newX, newY)) {
      player.x = newX;
      player.y = newY;
      stepCount++;
      if (stepCount >= maxSteps) {
        stepCount = 0;
        animateMazeTransition();
      } else {
        drawMaze();
      }
    }
  }
}

document.addEventListener("keydown", (e) => {
  switch (e.key) {
    case "ArrowUp": movePlayer(0, -1); break;
    case "ArrowDown": movePlayer(0, 1); break;
    case "ArrowLeft": movePlayer(-1, 0); break;
    case "ArrowRight": movePlayer(1, 0); break;
  }
});

maze = generateMaze();
drawMaze();
</script>
</body>
</html>
