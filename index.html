<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Laberinto GPS</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
      color: white;
      font-family: sans-serif;
    }
    canvas {
      display: block;
      background: black;
    }
    #info {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 14px;
      text-align: right;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">
    <div>Lat: <span id="lat">--</span></div>
    <div>Lon: <span id="lon">--</span></div>
    <div>Pasos: <span id="steps">0</span></div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let width, height;
function resizeCanvas() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const mazeSize = 15;
const cellSize = 40;
let maze = [];
let exitCell = { x: mazeSize - 1, y: mazeSize - 1 };

function generateMaze() {
  maze = Array.from({ length: mazeSize }, () =>
    Array.from({ length: mazeSize }, () => ({ top: true, right: true, bottom: true, left: true, visited: false }))
  );
  const stack = [];
  let current = { x: Math.floor(mazeSize / 2), y: Math.floor(mazeSize / 2) };
  maze[current.y][current.x].visited = true;
  stack.push(current);

  const dirs = [
    { dx: 0, dy: -1, wall: "top", opp: "bottom" },
    { dx: 1, dy: 0, wall: "right", opp: "left" },
    { dx: 0, dy: 1, wall: "bottom", opp: "top" },
    { dx: -1, dy: 0, wall: "left", opp: "right" },
  ];

  while (stack.length) {
    let curr = stack[stack.length - 1];
    let { x, y } = curr;
    let neighbors = [];

    for (let dir of dirs) {
      let nx = x + dir.dx, ny = y + dir.dy;
      if (nx >= 0 && ny >= 0 && nx < mazeSize && ny < mazeSize && !maze[ny][nx].visited) {
        neighbors.push({ ...dir, nx, ny });
      }
    }

    if (neighbors.length) {
      let chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
      maze[y][x][chosen.wall] = false;
      maze[chosen.ny][chosen.nx][chosen.opp] = false;
      maze[chosen.ny][chosen.nx].visited = true;
      stack.push({ x: chosen.nx, y: chosen.ny });
    } else {
      stack.pop();
    }
  }
}
generateMaze();

let player = {
  x: Math.floor(mazeSize / 2),
  y: Math.floor(mazeSize / 2),
  direction: 0,
};

let prevPos = null;
let stepCount = 0;
let info = document.getElementById("info");

function drawMaze() {
  ctx.save();
  ctx.translate(width / 2, height / 2);
  ctx.clearRect(-width/2, -height/2, width, height);
  const viewSize = Math.min(width, height);
  const scale = viewSize / (cellSize * 10);
  ctx.scale(scale, scale);
  ctx.translate(-player.x * cellSize - cellSize / 2, -player.y * cellSize - cellSize / 2);

  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;

  for (let y = 0; y < mazeSize; y++) {
    for (let x = 0; x < mazeSize; x++) {
      const cell = maze[y][x];
      const cx = x * cellSize;
      const cy = y * cellSize;

      if (cell.top) {
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + cellSize, cy);
        ctx.stroke();
      }
      if (cell.right) {
        ctx.beginPath();
        ctx.moveTo(cx + cellSize, cy);
        ctx.lineTo(cx + cellSize, cy + cellSize);
        ctx.stroke();
      }
      if (cell.bottom) {
        ctx.beginPath();
        ctx.moveTo(cx, cy + cellSize);
        ctx.lineTo(cx + cellSize, cy + cellSize);
        ctx.stroke();
      }
      if (cell.left) {
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx, cy + cellSize);
        ctx.stroke();
      }
    }
  }

  // Dibuja salida
  ctx.fillStyle = "green";
  ctx.fillRect(exitCell.x * cellSize + cellSize / 4, exitCell.y * cellSize + cellSize / 4, cellSize / 2, cellSize / 2);

  // Dibuja jugador
  ctx.save();
  ctx.translate(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 2);
  ctx.rotate(player.direction);
  ctx.beginPath();
  ctx.moveTo(0, -cellSize / 3); // punta
  ctx.lineTo(-cellSize / 4, cellSize / 4);
  ctx.lineTo(cellSize / 4, cellSize / 4);
  ctx.closePath();
  ctx.fillStyle = "red";
  ctx.fill();
  ctx.restore();

  ctx.restore();
}

function canMoveTo(nx, ny) {
  if (nx < 0 || ny < 0 || nx >= mazeSize || ny >= mazeSize) return false;
  const dx = nx - player.x;
  const dy = ny - player.y;
  const cell = maze[player.y][player.x];
  if (dx === 1 && cell.right === false) return true;
  if (dx === -1 && cell.left === false) return true;
  if (dy === 1 && cell.bottom === false) return true;
  if (dy === -1 && cell.top === false) return true;
  return false;
}

function moveToDirection(angle) {
  const directions = [
    { dx: 0, dy: -1, angle: 0 },
    { dx: 1, dy: 0, angle: 90 },
    { dx: 0, dy: 1, angle: 180 },
    { dx: -1, dy: 0, angle: 270 },
  ];
  let dir = directions.reduce((prev, curr) => {
    const diff = Math.abs(((curr.angle - angle + 360) % 360) - 180);
    return diff < prev.diff ? { ...curr, diff } : prev;
  }, { diff: Infinity });

  const nx = player.x + dir.dx;
  const ny = player.y + dir.dy;
  if (canMoveTo(nx, ny)) {
    player.x = nx;
    player.y = ny;
    stepCount++;
  }
}

function getDistanceMeters(pos1, pos2) {
  const R = 6371e3;
  const φ1 = pos1.latitude * Math.PI / 180;
  const φ2 = pos2.latitude * Math.PI / 180;
  const Δφ = (pos2.latitude - pos1.latitude) * Math.PI / 180;
  const Δλ = (pos2.longitude - pos1.longitude) * Math.PI / 180;

  const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

navigator.geolocation.watchPosition(pos => {
  const { latitude, longitude } = pos.coords;
  if (prevPos) {
    const dist = getDistanceMeters(prevPos, pos.coords);
    if (dist >= 0.5) {
      moveToDirection(player.direction * 180 / Math.PI);
      prevPos = pos.coords;
    }
  } else {
    prevPos = pos.coords;
  }
  info.innerText = `Lat: ${latitude.toFixed(5)}\nLng: ${longitude.toFixed(5)}\nPasos: ${stepCount}`;
}, err => {
  console.error("Error GPS", err);
  info.innerText = "Error al obtener GPS";
}, { enableHighAccuracy: true });

window.addEventListener("deviceorientation", e => {
  if (e.absolute || e.alpha !== null) {
    let deg = 360 - e.alpha;
    player.direction = deg * Math.PI / 180;
  }
});

function loop() {
  drawMaze();
  requestAnimationFrame(loop);
}
loop();
    


  </script>
</body>
</html>
