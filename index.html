<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Laberinto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
      background: white;
    }
    #fade {
      position: absolute;
      top: 0;
      left: 0;
      background: black;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 3s;
      z-index: 10;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div id="fade"></div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let cw, ch;
function resize() {
  canvas.width = cw = window.innerWidth;
  canvas.height = ch = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

const cellSize = 40;
const mazeCols = 50;
const mazeRows = 50;
let maze = [];
let seed = Date.now();
let rng = mulberry32(seed);

function mulberry32(a) {
  return function() {
    a |= 0; a = a + 0x6D2B79F5 | 0;
    let t = Math.imul(a ^ a >>> 15, 1 | a);
    t ^= t + Math.imul(t ^ t >>> 7, 61 | t);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(rng() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function generateMaze() {
  maze = Array.from({ length: mazeRows }, () =>
    Array.from({ length: mazeCols }, () => ({ top: true, right: true, bottom: true, left: true, visited: false }))
  );
  function carve(x, y) {
    maze[y][x].visited = true;
    const dirs = shuffle(['top', 'right', 'bottom', 'left']);
    for (const dir of dirs) {
      let nx = x, ny = y;
      if (dir === 'top') ny--;
      else if (dir === 'right') nx++;
      else if (dir === 'bottom') ny++;
      else if (dir === 'left') nx--;
      if (nx >= 0 && ny >= 0 && nx < mazeCols && ny < mazeRows && !maze[ny][nx].visited) {
        maze[y][x][dir] = false;
        maze[ny][nx][{ top: 'bottom', right: 'left', bottom: 'top', left: 'right' }[dir]] = false;
        carve(nx, ny);
      }
    }
  }
  carve(0, 0);
}

generateMaze();

let player = {
  x: Math.floor(mazeCols / 2),
  y: Math.floor(mazeRows / 2),
  angle: 0,
  targetAngle: 0
};

let targetCorner = [
  [0, 0],
  [mazeCols - 1, 0],
  [0, mazeRows - 1],
  [mazeCols - 1, mazeRows - 1]
][seed % 4];

let held = { up: false, down: false, left: false, right: false };

canvas.addEventListener('touchstart', e => {
  const x = e.touches[0].clientX;
  const y = e.touches[0].clientY;
  held.up = held.down = held.left = held.right = false;
  if (y < ch / 3) held.up = true;
  else if (y > 2 * ch / 3) held.down = true;
  else if (x < cw / 2) held.left = true;
  else held.right = true;
}, { passive: false });

canvas.addEventListener('touchend', () => {
  held.up = held.down = held.left = held.right = false;
});

function moveForward(dx, dy) {
  const nx = player.x + dx;
  const ny = player.y + dy;
  if (nx >= 0 && ny >= 0 && nx < mazeCols && ny < mazeRows) {
    const dir = dx === 1 ? 'right' : dx === -1 ? 'left' : dy === 1 ? 'bottom' : 'top';
    if (!maze[player.y][player.x][dir]) {
      player.x = nx;
      player.y = ny;
    }
  }
}

function updatePlayer() {
  if (held.up) player.targetAngle = 0;
  else if (held.right) player.targetAngle = Math.PI / 2;
  else if (held.down) player.targetAngle = Math.PI;
  else if (held.left) player.targetAngle = -Math.PI / 2;

  let diff = player.targetAngle - player.angle;
  diff = Math.atan2(Math.sin(diff), Math.cos(diff));
  player.angle += diff * 0.2;

  if (Math.abs(diff) < 0.1) {
    const dirX = Math.round(Math.cos(player.angle));
    const dirY = Math.round(Math.sin(player.angle));
    moveForward(dirX, dirY);
  }
}

function drawMaze() {
  const viewSize = Math.min(cw, ch) * 1.2;
  const offsetX = cw / 2 - player.x * cellSize;
  const offsetY = ch / 2 - player.y * cellSize;

  ctx.save();
  ctx.translate(offsetX, offsetY);

  ctx.lineWidth = 1;
  ctx.strokeStyle = 'black';

  for (let y = 0; y < mazeRows; y++) {
    for (let x = 0; x < mazeCols; x++) {
      const cell = maze[y][x];
      const px = x * cellSize;
      const py = y * cellSize;
      if (cell.top) { ctx.beginPath(); ctx.moveTo(px, py); ctx.lineTo(px + cellSize, py); ctx.stroke(); }
      if (cell.right) { ctx.beginPath(); ctx.moveTo(px + cellSize, py); ctx.lineTo(px + cellSize, py + cellSize); ctx.stroke(); }
      if (cell.bottom) { ctx.beginPath(); ctx.moveTo(px + cellSize, py + cellSize); ctx.lineTo(px, py + cellSize); ctx.stroke(); }
      if (cell.left) { ctx.beginPath(); ctx.moveTo(px, py + cellSize); ctx.lineTo(px, py); ctx.stroke(); }
    }
  }

  // Meta
  ctx.fillStyle = "red";
  ctx.fillRect(targetCorner[0]*cellSize+10, targetCorner[1]*cellSize+10, cellSize-20, cellSize-20);

  // Jugador
  const px = player.x * cellSize + cellSize / 2;
  const py = player.y * cellSize + cellSize / 2;
  const size = 12;
  ctx.save();
  ctx.translate(px, py);
  ctx.rotate(player.angle);
  ctx.beginPath();
  ctx.moveTo(0, -size);
  ctx.lineTo(-size / 2, size);
  ctx.lineTo(size / 2, size);
  ctx.closePath();
  ctx.fillStyle = "black";
  ctx.fill();
  ctx.restore();

  ctx.restore();
}

// --- Pista cada 30 segundos (modificable aquÃ­) ---
const pistaIntervalo = 30000; // milisegundos

function drawPista() {
  const dx = targetCorner[0] - player.x;
  const dy = targetCorner[1] - player.y;
  const angle = Math.atan2(dy, dx);
  const grad = ctx.createRadialGradient(cw/2, ch/2, 0, cw/2 + Math.cos(angle)*200, ch/2 + Math.sin(angle)*200, 400);
  grad.addColorStop(0, "rgba(255,255,0,0.3)");
  grad.addColorStop(1, "rgba(255,255,0,0)");
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, cw, ch);
  navigator.vibrate([100,100,100]);
}

function fadeTransition(callback) {
  const fade = document.getElementById("fade");
  fade.style.opacity = 1;
  setTimeout(() => {
    callback();
    fade.style.opacity = 0;
  }, 3000);
  navigator.vibrate(3000);
}

let lastChange = Date.now();
let lastPista = Date.now();

function loop() {
  ctx.clearRect(0, 0, cw, ch);
  updatePlayer();
  drawMaze();

  const now = Date.now();
  if (now - lastChange > 60000) {
    fadeTransition(() => {
      rng = mulberry32(seed);
      generateMaze();
      lastChange = now;
    });
  }

  if (now - lastPista > pistaIntervalo) {
    drawPista();
    lastPista = now;
  }

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
