<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Laberinto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: white;
    }
    canvas {
      display: block;
      background: white;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

// Tamaño del laberinto y celdas
const cols = 21;
const rows = 21;
const cellSize = Math.floor(height / 15);
const map = [];
let player = { x: Math.floor(cols/2), y: Math.floor(rows/2) };

// Salida en una esquina aleatoria
const corners = [
  { x: 0, y: 0 },
  { x: cols - 1, y: 0 },
  { x: 0, y: rows - 1 },
  { x: cols - 1, y: rows - 1 }
];
const exit = corners[Math.floor(Math.random() * corners.length)];

// Generador básico de laberinto (DFS)
function generateMaze() {
  for (let y = 0; y < rows; y++) {
    map[y] = [];
    for (let x = 0; x < cols; x++) {
      map[y][x] = { top: true, right: true, bottom: true, left: true, visited: false };
    }
  }

  function visit(x, y) {
    map[y][x].visited = true;
    const dirs = ['top', 'right', 'bottom', 'left'].sort(() => 0.5 - Math.random());
    for (let dir of dirs) {
      let nx = x, ny = y;
      if (dir === 'top') ny--;
      if (dir === 'right') nx++;
      if (dir === 'bottom') ny++;
      if (dir === 'left') nx--;

      if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && !map[ny][nx].visited) {
        map[y][x][dir] = false;
        if (dir === 'top') map[ny][nx].bottom = false;
        if (dir === 'right') map[ny][nx].left = false;
        if (dir === 'bottom') map[ny][nx].top = false;
        if (dir === 'left') map[ny][nx].right = false;
        visit(nx, ny);
      }
    }
  }

  visit(0, 0);
}

generateMaze();

// Dibujo del laberinto con líneas
function drawMaze(centerX, centerY) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 1;

  const offsetX = width / 2 - centerX * cellSize - cellSize / 2;
  const offsetY = height / 2 - centerY * cellSize - cellSize / 2;

  ctx.translate(offsetX, offsetY);
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const cell = map[y][x];
      const px = x * cellSize;
      const py = y * cellSize;

      if (cell.top) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + cellSize, py);
        ctx.stroke();
      }
      if (cell.right) {
        ctx.beginPath();
        ctx.moveTo(px + cellSize, py);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.bottom) {
        ctx.beginPath();
        ctx.moveTo(px, py + cellSize);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.left) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px, py + cellSize);
        ctx.stroke();
      }
    }
  }

  // Dibujar salida
  ctx.fillStyle = 'green';
  ctx.beginPath();
  ctx.arc(exit.x * cellSize + cellSize / 2, exit.y * cellSize + cellSize / 2, cellSize / 4, 0, Math.PI * 2);
  ctx.fill();

  // Dibujar jugador
  ctx.fillStyle = 'blue';
  ctx.beginPath();
  ctx.moveTo(player.x * cellSize + cellSize / 2, player.y * cellSize + cellSize / 4);
  ctx.lineTo(player.x * cellSize + cellSize / 4, player.y * cellSize + cellSize * 3 / 4);
  ctx.lineTo(player.x * cellSize + cellSize * 3 / 4, player.y * cellSize + cellSize * 3 / 4);
  ctx.closePath();
  ctx.fill();

  ctx.resetTransform();
}

// Movimiento
function movePlayer(dx, dy) {
  while (true) {
    const cell = map[player.y][player.x];
    let nextX = player.x + dx;
    let nextY = player.y + dy;

    if (nextX < 0 || nextX >= cols || nextY < 0 || nextY >= rows) break;

    const nextCell = map[nextY][nextX];

    const wall =
      (dx === -1 && cell.left) ||
      (dx === 1 && cell.right) ||
      (dy === -1 && cell.top) ||
      (dy === 1 && cell.bottom);

    if (wall) break;

    const exits = [
      !nextCell.top,
      !nextCell.right,
      !nextCell.bottom,
      !nextCell.left
    ].filter(Boolean).length;

    player.x = nextX;
    player.y = nextY;

    if (exits > 2 || (dx !== 0 && (!nextCell.left || !nextCell.right)) || (dy !== 0 && (!nextCell.top || !nextCell.bottom))) break;
  }
  drawMaze(player.x, player.y);
}

// Tocar pantalla para mover
canvas.addEventListener('touchstart', e => {
  const x = e.touches[0].clientX;
  const y = e.touches[0].clientY;
  if (y < height * 0.25) movePlayer(0, -1);
  else if (y > height * 0.75) movePlayer(0, 1);
  else if (x < width * 0.25) movePlayer(-1, 0);
  else if (x > width * 0.75) movePlayer(1, 0);
});

// Mostrar pista visual (gradiente direccional) cada 30 segundos
setInterval(() => {
  // Redibujar el laberinto para asegurarse de que no haya transformaciones activas
  drawMaze(player.x, player.y);

  const dx = exit.x - player.x;
  const dy = exit.y - player.y;
  const angle = Math.atan2(dy, dx);

  ctx.save();
  ctx.translate(width / 2, height / 2);
  ctx.rotate(angle);

  const grad = ctx.createLinearGradient(0, 0, width, 0);
  grad.addColorStop(0, "rgba(0,255,0,0.4)");
  grad.addColorStop(1, "rgba(0,255,0,0)");

  ctx.fillStyle = grad;
  ctx.fillRect(0, -height / 2, width, height);
  ctx.restore();

  setTimeout(() => {
    drawMaze(player.x, player.y);
  }, 1500);
}, 30000);

// Inicial
drawMaze(player.x, player.y);

</script>
</body>
</html>
