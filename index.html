<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Laberinto</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: white;
  }
  canvas {
    display: block;
    background: white;
  }
  #fade {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: black;
    opacity: 0;
    pointer-events: none;
    transition: opacity 3s;
    z-index: 10;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="fade"></div>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let width, height;
let cellSize = 20;
let cols, rows;
let maze = [];
let visited = [];
let stack = [];
let player = { x: 0, y: 0, angle: 0, targetAngle: 0 };
let keys = { up: false, down: false, left: false, right: false };
let lastMoveTime = 0;
let exit = { x: 0, y: 0 };
let seed = Date.now();
let lastMazeChange = Date.now();
let showHint = false;
let hintTimer = Date.now();
let fade = document.getElementById("fade");

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

function seedRandom(s) {
  return function() {
    s = Math.sin(s) * 10000;
    return s - Math.floor(s);
  };
}

function generateMaze() {
  const rand = seedRandom(seed);
  cols = Math.floor(100);
  rows = Math.floor(100);
  maze = Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => ({ top: true, right: true, bottom: true, left: true }))
  );
  visited = Array.from({ length: rows }, () => Array(cols).fill(false));
  stack = [];

  function walk(x, y) {
    visited[y][x] = true;
    const dirs = ["top", "right", "bottom", "left"];
    shuffle(dirs, rand);
    for (const dir of dirs) {
      const [dx, dy] = { top: [0, -1], right: [1, 0], bottom: [0, 1], left: [-1, 0] }[dir];
      const nx = x + dx, ny = y + dy;
      if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && !visited[ny][nx]) {
        maze[y][x][dir] = false;
        maze[ny][nx][{ top: "bottom", right: "left", bottom: "top", left: "right" }[dir]] = false;
        walk(nx, ny);
      }
    }
  }

  walk(Math.floor(cols / 2), Math.floor(rows / 2));
  player.x = Math.floor(cols / 2);
  player.y = Math.floor(rows / 2);
  player.angle = 0;
  player.targetAngle = 0;

  const corners = [
    { x: 0, y: 0 },
    { x: cols - 1, y: 0 },
    { x: 0, y: rows - 1 },
    { x: cols - 1, y: rows - 1 }
  ];
  exit = corners[Math.floor(rand() * 4)];
}

function shuffle(arr, rand) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function drawMaze() {
  const viewSize = Math.min(width, height);
  const viewCols = Math.floor(viewSize / cellSize);
  const camX = player.x - viewCols / 2;
  const camY = player.y - viewCols / 2;

  ctx.clearRect(0, 0, width, height);
  ctx.lineWidth = 1;
  ctx.strokeStyle = "black";

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const cell = maze[y][x];
      const sx = (x - camX) * cellSize;
      const sy = (y - camY) * cellSize;
      if (sx < -cellSize || sy < -cellSize || sx > width || sy > height) continue;
      ctx.beginPath();
      if (cell.top) ctx.moveTo(sx, sy), ctx.lineTo(sx + cellSize, sy);
      if (cell.right) ctx.moveTo(sx + cellSize, sy), ctx.lineTo(sx + cellSize, sy + cellSize);
      if (cell.bottom) ctx.moveTo(sx + cellSize, sy + cellSize), ctx.lineTo(sx, sy + cellSize);
      if (cell.left) ctx.moveTo(sx, sy + cellSize), ctx.lineTo(sx, sy);
      ctx.stroke();
    }
  }

  // Exit
  ctx.fillStyle = "green";
  ctx.fillRect((exit.x - camX) * cellSize + cellSize * 0.25, (exit.y - camY) * cellSize + cellSize * 0.25, cellSize / 2, cellSize / 2);

  // Player
  const px = (player.x - camX + 0.5) * cellSize;
  const py = (player.y - camY + 0.5) * cellSize;
  ctx.save();
  ctx.translate(px, py);
  ctx.rotate(player.angle);
  ctx.beginPath();
  ctx.moveTo(0, -cellSize * 0.4);
  ctx.lineTo(cellSize * 0.2, cellSize * 0.3);
  ctx.lineTo(-cellSize * 0.2, cellSize * 0.3);
  ctx.closePath();
  ctx.fillStyle = "red";
  ctx.fill();
  ctx.restore();

  // Hint
  if (showHint) {
    ctx.fillStyle = ctx.createRadialGradient(width / 2, height / 2, 10, width / 2, height / 2, 300);
    const dx = exit.x - player.x;
    const dy = exit.y - player.y;
    const angle = Math.atan2(dy, dx);
    const x = width / 2 + Math.cos(angle) * 100;
    const y = height / 2 + Math.sin(angle) * 100;
    const g = ctx.createRadialGradient(x, y, 10, x, y, 200);
    g.addColorStop(0, "rgba(255,255,0,0.3)");
    g.addColorStop(1, "rgba(255,255,0,0)");
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, width, height);
  }
}

function update() {
  const now = Date.now();

  if (keys.up || keys.down || keys.left || keys.right) {
    let dir = null;
    if (keys.up) dir = 0;
    if (keys.right) dir = Math.PI / 2;
    if (keys.down) dir = Math.PI;
    if (keys.left) dir = -Math.PI / 2;

    if (dir !== null) {
      let diff = dir - player.targetAngle;
      if (Math.abs(diff) > 0.1) {
        player.targetAngle = dir;
      } else {
        if (now - lastMoveTime > 150) {
          const dx = Math.round(Math.cos(player.angle));
          const dy = Math.round(Math.sin(player.angle));
          const nx = player.x + dx;
          const ny = player.y + dy;
          if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
            const from = maze[player.y][player.x];
            if ((dy === -1 && !from.top) ||
                (dx === 1 && !from.right) ||
                (dy === 1 && !from.bottom) ||
                (dx === -1 && !from.left)) {
              player.x = nx;
              player.y = ny;
              lastMoveTime = now;
            }
          }
        }
      }
    }
  }

  // Smooth rotation
  const da = player.targetAngle - player.angle;
  player.angle += da * 0.15;

  // Hint trigger
  if (now - hintTimer > 30000) { // <-- aquÃ­ puedes cambiar el intervalo de pista en milisegundos
    showHint = true;
    navigator.vibrate([100, 100, 100]);
    setTimeout(() => showHint = false, 3000);
    hintTimer = now;
  }

  // Maze regen
  if (now - lastMazeChange > 60000) {
    fade.style.opacity = 1;
    navigator.vibrate(3000);
    setTimeout(() => {
      seed = Date.now();
      generateMaze();
      lastMazeChange = Date.now();
      hintTimer = Date.now();
      fade.style.opacity = 0;
    }, 3000);
  }
}

function gameLoop() {
  update();
  drawMaze();
  requestAnimationFrame(gameLoop);
}

canvas.addEventListener("touchstart", e => {
  e.preventDefault();
  const x = e.touches[0].clientX;
  const y = e.touches[0].clientY;
  const centerX = width / 2;
  const centerY = height / 2;
  keys.up = y < centerY && Math.abs(y - centerY) > Math.abs(x - centerX);
  keys.down = y > centerY && Math.abs(y - centerY) > Math.abs(x - centerX);
  keys.left = x < centerX && Math.abs(x - centerX) > Math.abs(y - centerY);
  keys.right = x > centerX && Math.abs(x - centerX) > Math.abs(y - centerY);
});
canvas.addEventListener("touchend", () => {
  keys = { up: false, down: false, left: false, right: false };
});

generateMaze();
gameLoop();
</script>
</body>
</html>
