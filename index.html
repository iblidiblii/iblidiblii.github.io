<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Laberinto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: white;
    }
    canvas {
      display: block;
      background: white;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  let cellSize = 20;
  let cols = 41;
  let rows = 41;
  let maze = [];
  let stack = [];

  let player = { x: 1, y: 1, dir: "up", angle: 0 };
  let moveDir = null;
  let moving = false;

  const directions = [
    { x: 0, y: -1, name: "up", angle: -Math.PI / 2 },
    { x: 1, y: 0, name: "right", angle: 0 },
    { x: 0, y: 1, name: "down", angle: Math.PI / 2 },
    { x: -1, y: 0, name: "left", angle: Math.PI }
  ];

  const cameraZoom = 5;

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // Laberinto inicial
  function generateMaze() {
    maze = [];
    for (let y = 0; y < rows; y++) {
      maze[y] = [];
      for (let x = 0; x < cols; x++) {
        maze[y][x] = { visited: false, walls: [true, true, true, true] };
      }
    }

    let current = { x: 1, y: 1 };
    maze[1][1].visited = true;
    stack.push(current);

    while (stack.length > 0) {
      let current = stack[stack.length - 1];
      let next = getUnvisitedNeighbor(current.x, current.y);

      if (next) {
        removeWalls(current, next);
        maze[next.y][next.x].visited = true;
        stack.push(next);
      } else {
        stack.pop();
      }
    }
  }

  function getUnvisitedNeighbor(x, y) {
    const neighbors = [];

    if (y > 1 && !maze[y - 2][x].visited) neighbors.push({ x: x, y: y - 2 });
    if (y < rows - 2 && !maze[y + 2][x].visited) neighbors.push({ x: x, y: y + 2 });
    if (x > 1 && !maze[y][x - 2].visited) neighbors.push({ x: x - 2, y: y });
    if (x < cols - 2 && !maze[y][x + 2].visited) neighbors.push({ x: x + 2, y: y });

    if (neighbors.length === 0) return undefined;
    return neighbors[Math.floor(Math.random() * neighbors.length)];
  }

  function removeWalls(a, b) {
    let dx = b.x - a.x;
    let dy = b.y - a.y;

    if (dx === 2) {
      maze[a.y][a.x].walls[1] = false;
      maze[b.y][b.x].walls[3] = false;
    } else if (dx === -2) {
      maze[a.y][a.x].walls[3] = false;
      maze[b.y][b.x].walls[1] = false;
    }

    if (dy === 2) {
      maze[a.y][a.x].walls[2] = false;
      maze[b.y][b.x].walls[0] = false;
    } else if (dy === -2) {
      maze[a.y][a.x].walls[0] = false;
      maze[b.y][b.x].walls[2] = false;
    }
  }

  function drawMaze() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const offsetX = canvas.width / 2 - player.x * cellSize;
    const offsetY = canvas.height / 2 - player.y * cellSize;

    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;

    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        let cell = maze[y][x];
        let px = x * cellSize + offsetX;
        let py = y * cellSize + offsetY;

        if (cell.walls[0])
          drawLine(px, py, px + cellSize, py);
        if (cell.walls[1])
          drawLine(px + cellSize, py, px + cellSize, py + cellSize);
        if (cell.walls[2])
          drawLine(px + cellSize, py + cellSize, px, py + cellSize);
        if (cell.walls[3])
          drawLine(px, py + cellSize, px, py);
      }
    }

    // Salida (esquina inferior derecha)
    ctx.fillStyle = "green";
    ctx.beginPath();
    ctx.arc((cols - 2) * cellSize + offsetX + cellSize / 2, (rows - 2) * cellSize + offsetY + cellSize / 2, 5, 0, 2 * Math.PI);
    ctx.fill();

    // Jugador (triángulo)
    ctx.save();
    ctx.translate(player.x * cellSize + offsetX + cellSize / 2, player.y * cellSize + offsetY + cellSize / 2);
    ctx.rotate(player.angle);
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.moveTo(0, -cellSize / 2);
    ctx.lineTo(-cellSize / 3, cellSize / 3);
    ctx.lineTo(cellSize / 3, cellSize / 3);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawLine(x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
  }

  function getAvailableDirs(x, y) {
    let dirs = [];
    if (!maze[y][x].walls[0]) dirs.push("up");
    if (!maze[y][x].walls[1]) dirs.push("right");
    if (!maze[y][x].walls[2]) dirs.push("down");
    if (!maze[y][x].walls[3]) dirs.push("left");
    return dirs;
  }

  function movePlayer(dir) {
    let d = directions.find(d => d.name === dir);
    let lastDir = dir;
    player.angle = d.angle;

    let interval = setInterval(() => {
      let cx = player.x;
      let cy = player.y;
      let dirs = getAvailableDirs(cx, cy);

      let dx = d.x;
      let dy = d.y;

      // Si hay una pared delante, parar
      if ((dx === 0 && dy === -1 && maze[cy][cx].walls[0]) ||
          (dx === 1 && dy === 0 && maze[cy][cx].walls[1]) ||
          (dx === 0 && dy === 1 && maze[cy][cx].walls[2]) ||
          (dx === -1 && dy === 0 && maze[cy][cx].walls[3])) {
        clearInterval(interval);
        return;
      }

      // Calcular nueva posición
      let nx = cx + dx;
      let ny = cy + dy;

      // Comprobar bifurcación (más de dos caminos posibles)
      let newDirs = getAvailableDirs(nx, ny);
      if (newDirs.length > 2) {
        player.x = nx;
        player.y = ny;
        clearInterval(interval);
        return;
      }

      // Mover
      player.x = nx;
      player.y = ny;
      drawMaze();
    }, 100);
  }

  canvas.addEventListener("click", e => {
    const x = e.clientX;
    const y = e.clientY;
    const w = canvas.width;
    const h = canvas.height;

    if (y < h / 3) movePlayer("up");
    else if (y > 2 * h / 3) movePlayer("down");
    else if (x < w / 3) movePlayer("left");
    else if (x > 2 * w / 3) movePlayer("right");
  });

  // Inicialización
  generateMaze();
  drawMaze();

</script>
</body>
</html>
