<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Laberinto con Líneas Finas</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: white;
    }
    canvas {
      display: block;
      background: white;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // Configuración del laberinto
    const mazeCols = 31;
    const mazeRows = 31;
    const cellSize = Math.floor(height / 15); // para móvil: alto determina escala
    const mazeWidth = mazeCols * cellSize;
    const mazeHeight = mazeRows * cellSize;

    // Generador de laberintos (DFS)
    function generateMaze(cols, rows) {
      let maze = Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => ({
          visited: false,
          top: true,
          right: true,
          bottom: true,
          left: true,
        }))
      );

      function visit(row, col) {
        maze[row][col].visited = true;
        const directions = [
          [0, -1, 'top', 'bottom'],
          [1, 0, 'right', 'left'],
          [0, 1, 'bottom', 'top'],
          [-1, 0, 'left', 'right']
        ].sort(() => Math.random() - 0.5);

        for (let [dx, dy, wall, opposite] of directions) {
          const nx = col + dx;
          const ny = row + dy;
          if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && !maze[ny][nx].visited) {
            maze[row][col][wall] = false;
            maze[ny][nx][opposite] = false;
            visit(ny, nx);
          }
        }
      }

      visit(0, 0);
      return maze;
    }

    const maze = generateMaze(mazeCols, mazeRows);

    // Jugador
    let player = {
      x: Math.floor(mazeCols / 2),
      y: Math.floor(mazeRows / 2)
    };

    // Coordenadas de salida (esquina aleatoria)
    const exitCorners = [
      [0, 0],
      [0, mazeCols - 1],
      [mazeRows - 1, 0],
      [mazeRows - 1, mazeCols - 1]
    ];
    const exit = exitCorners[Math.floor(Math.random() * 4)];

    // Dibujar laberinto
    function drawMaze(centerX, centerY) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 1;

      const startX = Math.floor(centerX - canvas.width / 2 / cellSize);
      const startY = Math.floor(centerY - canvas.height / 2 / cellSize);
      const endX = startX + Math.ceil(canvas.width / cellSize) + 1;
      const endY = startY + Math.ceil(canvas.height / cellSize) + 1;

      for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
          if (x < 0 || y < 0 || x >= mazeCols || y >= mazeRows) continue;
          const cell = maze[y][x];
          const px = (x - centerX) * cellSize + canvas.width / 2;
          const py = (y - centerY) * cellSize + canvas.height / 2;

          ctx.beginPath();
          if (cell.top) {
            ctx.moveTo(px, py);
            ctx.lineTo(px + cellSize, py);
          }
          if (cell.right) {
            ctx.moveTo(px + cellSize, py);
            ctx.lineTo(px + cellSize, py + cellSize);
          }
          if (cell.bottom) {
            ctx.moveTo(px, py + cellSize);
            ctx.lineTo(px + cellSize, py + cellSize);
          }
          if (cell.left) {
            ctx.moveTo(px, py);
            ctx.lineTo(px, py + cellSize);
          }
          ctx.stroke();
        }
      }

      // Salida
      const ex = (exit[1] - centerX) * cellSize + canvas.width / 2;
      const ey = (exit[0] - centerY) * cellSize + canvas.height / 2;
      ctx.fillStyle = "green";
      ctx.beginPath();
      ctx.arc(ex + cellSize / 2, ey + cellSize / 2, cellSize / 4, 0, Math.PI * 2);
      ctx.fill();

      // Jugador
      const px = canvas.width / 2;
      const py = canvas.height / 2;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(px + cellSize / 2, py + cellSize / 2, cellSize / 4, 0, Math.PI * 2);
      ctx.fill();
    }

    // Movimiento por pantalla táctil (cuatro zonas)
    canvas.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;

      const thirdX = width / 3;
      const thirdY = height / 3;

      const cell = maze[player.y][player.x];

      if (y < thirdY && !cell.top) player.y--;
      else if (y > 2 * thirdY && !cell.bottom) player.y++;
      else if (x < thirdX && !cell.left) player.x--;
      else if (x > 2 * thirdX && !cell.right) player.x++;

      drawMaze(player.x, player.y);
    });

    drawMaze(player.x, player.y);

    window.addEventListener("resize", () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      drawMaze(player.x, player.y);
    });
  </script>
</body>
</html>
