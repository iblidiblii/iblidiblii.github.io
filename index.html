<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Laberinto Móvil</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      background: white;
      touch-action: none;
    }
    canvas {
      display: block;
      background: white;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // Ajustar tamaño a móvil vertical: el ancho del laberinto será al menos igual al alto de pantalla
    let screenWidth = window.innerWidth;
    let screenHeight = window.innerHeight;
    canvas.width = screenWidth;
    canvas.height = screenHeight;

    // Tamaño del laberinto
    const cellSize = 20;
    const cols = Math.floor(Math.max(screenHeight, screenWidth) / cellSize);
    const rows = cols;

    const maze = Array.from({ length: rows }, () => Array(cols).fill(1)); // 1 = pared, 0 = camino

    // Generar laberinto (DFS)
    function generateMaze() {
      const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
      const dx = [0, 1, 0, -1];
      const dy = [-1, 0, 1, 0];

      function isValid(x, y) {
        return x >= 0 && y >= 0 && x < cols && y < rows;
      }

      function carve(x, y) {
        visited[y][x] = true;
        maze[y][x] = 0;
        const dirs = [0, 1, 2, 3].sort(() => Math.random() - 0.5);
        for (let i of dirs) {
          const nx = x + dx[i] * 2;
          const ny = y + dy[i] * 2;
          if (isValid(nx, ny) && !visited[ny][nx]) {
            maze[y + dy[i]][x + dx[i]] = 0;
            carve(nx, ny);
          }
        }
      }

      carve(Math.floor(cols / 2), Math.floor(rows / 2));
    }

    generateMaze();

    // Posición del jugador (empieza en el centro)
    let player = {
      x: Math.floor(cols / 2),
      y: Math.floor(rows / 2),
      angle: 0 // en radianes, para dirección
    };

    const exitCorner = Math.floor(Math.random() * 4); // 0=TL, 1=TR, 2=BR, 3=BL
    let exit = { x: 0, y: 0 };
    if (exitCorner === 0) exit = { x: 1, y: 1 };
    if (exitCorner === 1) exit = { x: cols - 2, y: 1 };
    if (exitCorner === 2) exit = { x: cols - 2, y: rows - 2 };
    if (exitCorner === 3) exit = { x: 1, y: rows - 2 };
    maze[exit.y][exit.x] = 0;

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const visibleRadius = Math.floor(canvas.width / cellSize / 2);

      const startX = Math.max(0, player.x - visibleRadius);
      const startY = Math.max(0, player.y - visibleRadius);
      const endX = Math.min(cols, player.x + visibleRadius + 1);
      const endY = Math.min(rows, player.y + visibleRadius + 1);

      const offsetX = canvas.width / 2 - player.x * cellSize;
      const offsetY = canvas.height / 2 - player.y * cellSize;

      ctx.strokeStyle = "#000";
      ctx.lineWidth = 1;

      for (let y = startY; y < endY; y++) {
        for (let x = startX; x < endX; x++) {
          if (maze[y][x] === 1) {
            ctx.strokeRect(x * cellSize + offsetX, y * cellSize + offsetY, cellSize, cellSize);
          }
        }
      }

      // Salida
      ctx.fillStyle = "green";
      ctx.fillRect(exit.x * cellSize + offsetX, exit.y * cellSize + offsetY, cellSize, cellSize);

      // Jugador como triángulo
      const px = player.x * cellSize + cellSize / 2 + offsetX;
      const py = player.y * cellSize + cellSize / 2 + offsetY;

      const size = cellSize * 0.5;
      ctx.fillStyle = "blue";
      ctx.beginPath();
      ctx.moveTo(px + size * Math.cos(player.angle), py + size * Math.sin(player.angle));
      ctx.lineTo(px + size * Math.cos(player.angle + 2.5), py + size * Math.sin(player.angle + 2.5));
      ctx.lineTo(px + size * Math.cos(player.angle - 2.5), py + size * Math.sin(player.angle - 2.5));
      ctx.closePath();
      ctx.fill();
    }

    function canMove(x, y) {
      return maze[y] && maze[y][x] === 0;
    }

    function move(dx, dy, angle) {
      const nx = player.x + dx;
      const ny = player.y + dy;
      if (canMove(nx, ny)) {
        player.x = nx;
        player.y = ny;
        player.angle = angle;
      }
    }

    // Controles por pantalla táctil (dividir la pantalla en 4 zonas)
    canvas.addEventListener("touchstart", (e) => {
      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;

      const thirdW = canvas.width / 3;
      const thirdH = canvas.height / 3;

      if (y < thirdH) move(0, -1, -Math.PI / 2); // arriba
      else if (y > 2 * thirdH) move(0, 1, Math.PI / 2); // abajo
      else if (x < thirdW) move(-1, 0, Math.PI); // izquierda
      else if (x > 2 * thirdW) move(1, 0, 0); // derecha
    });

    // Controles por teclado
    window.addEventListener("keydown", e => {
      if (e.key === "ArrowUp") move(0, -1, -Math.PI / 2);
      if (e.key === "ArrowDown") move(0, 1, Math.PI / 2);
      if (e.key === "ArrowLeft") move(-1, 0, Math.PI);
      if (e.key === "ArrowRight") move(1, 0, 0);
    });

    function gameLoop() {
      draw();
      requestAnimationFrame(gameLoop);
    }

    gameLoop();
  </script>
</body>
</html>
