<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Laberinto</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: white;
      overflow: hidden;
    }
    canvas {
      display: block;
      background: white;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let w = canvas.width = window.innerWidth;
let h = canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
});

const mazeSize = 41; // Odd number for full walls around
const cellSize = 10;
let maze = [];
let seed = Date.now();
let player = {
  x: Math.floor(mazeSize / 2),
  y: Math.floor(mazeSize / 2),
  angle: 0,
  targetAngle: 0,
};
let direction = { x: 0, y: 0 };

function seededRandom(seed) {
  return () => {
    seed = (seed * 16807) % 2147483647;
    return (seed - 1) / 2147483646;
  };
}

function generateMaze() {
  const rand = seededRandom(seed);
  maze = Array(mazeSize).fill(0).map(() => Array(mazeSize).fill(1));
  function carve(x, y) {
    const dirs = [
      [0, -2], [2, 0], [0, 2], [-2, 0]
    ].sort(() => rand() - 0.5);
    for (let [dx, dy] of dirs) {
      const nx = x + dx, ny = y + dy;
      if (ny > 0 && ny < mazeSize-1 && nx > 0 && nx < mazeSize-1 && maze[ny][nx] === 1) {
        maze[ny][nx] = 0;
        maze[y + dy/2][x + dx/2] = 0;
        carve(nx, ny);
      }
    }
  }
  maze[player.y][player.x] = 0;
  carve(player.x, player.y);
}
generateMaze();

function drawMaze() {
  const camX = player.x * cellSize;
  const camY = player.y * cellSize;

  const viewSize = Math.min(w, h) * 0.9;
  const scale = viewSize / (cellSize * 15);

  ctx.setTransform(scale, 0, 0, scale, w/2 - camX * scale, h/2 - camY * scale);
  ctx.clearRect(camX - w/scale, camY - h/scale, w*2/scale, h*2/scale);

  // Dibujar laberinto
  ctx.strokeStyle = "black";
  ctx.lineWidth = 0.5;
  for (let y = 0; y < mazeSize; y++) {
    for (let x = 0; x < mazeSize; x++) {
      if (maze[y][x] === 1) {
        ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
      }
    }
  }

  // Salida
  ctx.fillStyle = "green";
  ctx.beginPath();
  ctx.arc((mazeSize-2) * cellSize + cellSize/2, (mazeSize-2) * cellSize + cellSize/2, cellSize/3, 0, Math.PI*2);
  ctx.fill();

  // Jugador (flecha)
  const px = player.x * cellSize + cellSize / 2;
  const py = player.y * cellSize + cellSize / 2;
  player.angle += (player.targetAngle - player.angle) * 0.15;

  ctx.save();
  ctx.translate(px, py);
  ctx.rotate(player.angle);
  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.moveTo(0, -cellSize * 0.5);
  ctx.lineTo(cellSize * 0.3, cellSize * 0.5);
  ctx.lineTo(-cellSize * 0.3, cellSize * 0.5);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function movePlayer() {
  const nx = player.x + direction.x;
  const ny = player.y + direction.y;
  if (maze[ny] && maze[ny][nx] === 0) {
    player.x = nx;
    player.y = ny;
    const angleMap = { "0,-1": -Math.PI/2, "1,0": 0, "0,1": Math.PI/2, "-1,0": Math.PI };
    player.targetAngle = angleMap[`${direction.x},${direction.y}`] || player.angle;
  }
}

setInterval(() => {
  if (direction.x !== 0 || direction.y !== 0) {
    movePlayer();
  }
}, 150);

function update() {
  drawMaze();
  requestAnimationFrame(update);
}
update();

// Movimiento por pulsación táctil o ratón
canvas.addEventListener("mousedown", handleClick);
canvas.addEventListener("touchstart", e => handleClick(e.touches[0]));

function handleClick(e) {
  const cx = w / 2, cy = h / 2;
  const dx = e.clientX - cx;
  const dy = e.clientY - cy;
  if (Math.abs(dx) > Math.abs(dy)) {
    direction = dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 };
  } else {
    direction = dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 };
  }
}

canvas.addEventListener("mouseup", () => direction = { x: 0, y: 0 });
canvas.addEventListener("touchend", () => direction = { x: 0, y: 0 });

// Teclado
document.addEventListener("keydown", e => {
  if (e.key === "ArrowUp") direction = { x: 0, y: -1 };
  if (e.key === "ArrowDown") direction = { x: 0, y: 1 };
  if (e.key === "ArrowLeft") direction = { x: -1, y: 0 };
  if (e.key === "ArrowRight") direction = { x: 1, y: 0 };
});
document.addEventListener("keyup", () => direction = { x: 0, y: 0 });
</script>
</body>
</html>
