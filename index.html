<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Laberinto Descubrimiento</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
      background: white;
    }
    #fade {
      position: absolute;
      top: 0; left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      opacity: 0;
      transition: opacity 1.5s;
      pointer-events: none;
    }
    #controls {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 10;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="fade"></div>
<div id="controls"></div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const fade = document.getElementById("fade");
const controls = document.getElementById("controls");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let cols = 31, rows = 31;
let cellSize = 40;
let maze = [];
let visited = [];
let stack = [];
let player = { x: 15, y: 15, angle: 0, targetAngle: 0 };
let keys = { up: false, down: false, left: false, right: false };
let lastChange = Date.now();
let lastHint = Date.now();
let hintDuration = 5000;
let showHint = false;

const hintInterval = 30000; // ← ← ← TIEMPO ENTRE PISTAS EN MILISEGUNDOS (30s)

let goal = { x: 0, y: 0 };
let seed = Date.now();

function srand(seed) {
  return function() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  };
}

function shuffle(arr, rand) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function generateMaze(seed) {
  const rand = srand(seed);
  maze = Array(rows).fill().map(() => Array(cols).fill({ top: true, right: true, bottom: true, left: true }));
  visited = Array(rows).fill().map(() => Array(cols).fill(false));
  stack = [];
  const dir = [
    { dx: 0, dy: -1, wall: "top", opposite: "bottom" },
    { dx: 1, dy: 0, wall: "right", opposite: "left" },
    { dx: 0, dy: 1, wall: "bottom", opposite: "top" },
    { dx: -1, dy: 0, wall: "left", opposite: "right" }
  ];
  function carve(x, y) {
    visited[y][x] = true;
    let directions = [...dir];
    shuffle(directions, rand);
    for (const d of directions) {
      const nx = x + d.dx;
      const ny = y + d.dy;
      if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && !visited[ny][nx]) {
        maze[y][x][d.wall] = false;
        maze[ny][nx][d.opposite] = false;
        carve(nx, ny);
      }
    }
  }
  carve(0, 0);
  const corners = [
    { x: 0, y: 0 },
    { x: cols - 1, y: 0 },
    { x: 0, y: rows - 1 },
    { x: cols - 1, y: rows - 1 }
  ];
  goal = corners[Math.floor(rand() * corners.length)];
}

function drawMaze() {
  ctx.strokeStyle = "black";
  ctx.lineWidth = 1;
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const cell = maze[y][x];
      const px = x * cellSize - player.x * cellSize + canvas.width / 2;
      const py = y * cellSize - player.y * cellSize + canvas.height / 2;
      if (cell.top) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + cellSize, py);
        ctx.stroke();
      }
      if (cell.right) {
        ctx.beginPath();
        ctx.moveTo(px + cellSize, py);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.bottom) {
        ctx.beginPath();
        ctx.moveTo(px, py + cellSize);
        ctx.lineTo(px + cellSize, py + cellSize);
        ctx.stroke();
      }
      if (cell.left) {
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px, py + cellSize);
        ctx.stroke();
      }
    }
  }

  // Salida
  const gx = goal.x * cellSize - player.x * cellSize + canvas.width / 2;
  const gy = goal.y * cellSize - player.y * cellSize + canvas.height / 2;
  ctx.fillStyle = "red";
  ctx.fillRect(gx + 10, gy + 10, cellSize - 20, cellSize - 20);
}

function drawPlayer() {
  const px = canvas.width / 2;
  const py = canvas.height / 2;
  const size = 20;

  ctx.save();
  ctx.translate(px, py);
  ctx.rotate(player.angle);
  ctx.beginPath();
  ctx.moveTo(0, -size);
  ctx.lineTo(-size / 2, size);
  ctx.lineTo(size / 2, size);
  ctx.closePath();
  ctx.fillStyle = "blue";
  ctx.fill();
  ctx.restore();
}

function drawHint() {
  const dx = goal.x - player.x;
  const dy = goal.y - player.y;
  const angle = Math.atan2(dy, dx);

  const grad = ctx.createRadialGradient(
    canvas.width / 2, canvas.height / 2, 0,
    canvas.width / 2 + Math.cos(angle) * 200,
    canvas.height / 2 + Math.sin(angle) * 200, 400
  );
  grad.addColorStop(0, "rgba(255,255,0,0.3)");
  grad.addColorStop(1, "rgba(255,255,0,0)");

  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (showHint && Date.now() - lastHint < hintDuration) drawHint();

  drawMaze();
  drawPlayer();

  // Movimiento
  const speed = 0.05;
  if (keys.up) {
    if (Math.abs(normalizeAngle(player.angle - player.targetAngle)) < 0.1) {
      const dx = Math.round(Math.cos(player.angle));
      const dy = Math.round(Math.sin(player.angle));
      const nx = player.x + dx;
      const ny = player.y + dy;
      if (ny >= 0 && ny < rows && nx >= 0 && nx < cols && !maze[player.y][player.x][getWall(dx, dy)]) {
        player.x = nx;
        player.y = ny;
      }
    }
  }

  // Rotación suave
  player.angle += normalizeAngle(player.targetAngle - player.angle) * speed;

  // Cambio de laberinto
  if (Date.now() - lastChange > 60000) {
    navigator.vibrate(3000);
    fade.style.opacity = 1;
    setTimeout(() => {
      generateMaze(seed);
      fade.style.opacity = 0;
      lastChange = Date.now();
    }, 1500);
  }

  // Pista
  if (Date.now() - lastHint > hintInterval) {
    showHint = true;
    lastHint = Date.now();
    navigator.vibrate([200, 200, 200]);
    setTimeout(() => (showHint = false), hintDuration);
  }

  requestAnimationFrame(update);
}

function normalizeAngle(a) {
  return Math.atan2(Math.sin(a), Math.cos(a));
}

function getWall(dx, dy) {
  if (dx === 1) return "right";
  if (dx === -1) return "left";
  if (dy === 1) return "bottom";
  if (dy === -1) return "top";
}

generateMaze(seed);
update();

// Control por pulsación
let hold = null;
controls.addEventListener("touchstart", e => {
  const x = e.touches[0].clientX;
  const y = e.touches[0].clientY;
  const cx = canvas.width / 2;
  const cy = canvas.height / 2;
  const angle = Math.atan2(y - cy, x - cx);
  player.targetAngle = angle;
  keys.up = true;
  hold = setInterval(() => keys.up = true, 100);
});

controls.addEventListener("touchend", () => {
  clearInterval(hold);
  keys.up = false;
});
</script>
</body>
</html>
