<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Laberinto Auto-Movimiento</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: white;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const CELL_SIZE = 20;
const MAZE_COLS = 41; // impar
const MAZE_ROWS = 41;
let maze = [];
let player = { x: 1, y: 1 };
let goal = { x: MAZE_COLS - 2, y: MAZE_ROWS - 2 };
let cameraZoom = 10;

function initMaze() {
  maze = Array.from({ length: MAZE_ROWS }, () =>
    Array(MAZE_COLS).fill(1)
  );
  carve(1, 1);
  player = { x: 1, y: 1 };
  goal = getRandomCornerExit();
}
function getRandomCornerExit() {
  const corners = [
    { x: 1, y: 1 },
    { x: 1, y: MAZE_ROWS - 2 },
    { x: MAZE_COLS - 2, y: 1 },
    { x: MAZE_COLS - 2, y: MAZE_ROWS - 2 }
  ];
  return corners[Math.floor(Math.random() * corners.length)];
}

function carve(x, y) {
  const dirs = shuffle([
    [0, -2],
    [0, 2],
    [-2, 0],
    [2, 0]
  ]);
  maze[y][x] = 0;
  for (const [dx, dy] of dirs) {
    const nx = x + dx, ny = y + dy;
    if (
      nx > 0 &&
      ny > 0 &&
      nx < MAZE_COLS - 1 &&
      ny < MAZE_ROWS - 1 &&
      maze[ny][nx] === 1
    ) {
      maze[y + dy / 2][x + dx / 2] = 0;
      carve(nx, ny);
    }
  }
}

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

function drawMaze() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const viewSize = canvas.width / cameraZoom;
  const offsetX = player.x * CELL_SIZE - viewSize / 2;
  const offsetY = player.y * CELL_SIZE - viewSize / 2;

  ctx.lineWidth = 1;
  ctx.strokeStyle = "#000";

  for (let y = 0; y < MAZE_ROWS; y++) {
    for (let x = 0; x < MAZE_COLS; x++) {
      if (maze[y][x] === 1) {
        const px = x * CELL_SIZE - offsetX;
        const py = y * CELL_SIZE - offsetY;
        ctx.beginPath();
        ctx.rect(px, py, CELL_SIZE, CELL_SIZE);
        ctx.stroke();
      }
    }
  }

  // Dibujar salida
  ctx.fillStyle = "green";
  const gx = goal.x * CELL_SIZE - offsetX + CELL_SIZE / 4;
  const gy = goal.y * CELL_SIZE - offsetY + CELL_SIZE / 4;
  ctx.beginPath();
  ctx.arc(gx, gy, CELL_SIZE / 4, 0, 2 * Math.PI);
  ctx.fill();

  // Dibujar jugador
  ctx.fillStyle = "red";
  const px = player.x * CELL_SIZE - offsetX;
  const py = player.y * CELL_SIZE - offsetY;
  ctx.beginPath();
  ctx.arc(px + CELL_SIZE / 2, py + CELL_SIZE / 2, CELL_SIZE / 3, 0, 2 * Math.PI);
  ctx.fill();
}

function moveUntilBlocked(dirX, dirY) {
  let moved = false;
  while (true) {
    const nx = player.x + dirX;
    const ny = player.y + dirY;
    if (
      nx >= 0 && ny >= 0 &&
      nx < MAZE_COLS && ny < MAZE_ROWS &&
      maze[ny][nx] === 0
    ) {
      // Chequear si hay bifurcaciÃ³n adelante
      const options = [
        [0, -1],
        [0, 1],
        [-1, 0],
        [1, 0]
      ];
      let paths = 0;
      for (const [dx, dy] of options) {
        const cx = nx + dx;
        const cy = ny + dy;
        if (
          cx >= 0 && cy >= 0 &&
          cx < MAZE_COLS && cy < MAZE_ROWS &&
          maze[cy][cx] === 0 &&
          !(dx === -dirX && dy === -dirY) // No contar el camino de vuelta
        ) {
          paths++;
        }
      }
      player.x = nx;
      player.y = ny;
      moved = true;
      if (paths > 1) break;
    } else {
      break;
    }
  }
  if (moved) drawMaze();
}

canvas.addEventListener("click", (e) => {
  const w = canvas.width;
  const h = canvas.height;
  const x = e.clientX;
  const y = e.clientY;

  const thirdW = w / 3;
  const thirdH = h / 3;

  if (y < thirdH) moveUntilBlocked(0, -1); // arriba
  else if (y > 2 * thirdH) moveUntilBlocked(0, 1); // abajo
  else if (x < thirdW) moveUntilBlocked(-1, 0); // izquierda
  else if (x > 2 * thirdW) moveUntilBlocked(1, 0); // derecha
});

initMaze();
drawMaze();
</script>
</body>
</html>
