<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Laberinto GPS</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-family: monospace;
      font-size: 14px;
      background: rgba(0, 0, 0, 0.6);
      padding: 6px 8px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="info">Lat: --<br>Lon: --<br>Pasos: 0</div>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    let width, height;
    function resizeCanvas() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    const cols = 15;
    const rows = 15;
    const maze = [];
    const cellSize = 40;
    const visibleCells = 7;
    const halfVisible = Math.floor(visibleCells / 2);

    let player = {
      x: Math.floor(cols / 2),
      y: Math.floor(rows / 2),
      lat: null,
      lon: null,
      steps: 0,
      angle: 0
    };

    let lastLat = null;
    let lastLon = null;
    let exitCell = { x: 0, y: 0 };

    function createMaze() {
      for (let y = 0; y < rows; y++) {
        maze[y] = [];
        for (let x = 0; x < cols; x++) {
          maze[y][x] = { top: true, right: true, bottom: true, left: true };
        }
      }

      function carve(x, y, visited = {}) {
        visited[`${x},${y}`] = true;
        const dirs = ["top", "right", "bottom", "left"].sort(() => Math.random() - 0.5);
        for (const dir of dirs) {
          let nx = x, ny = y;
          if (dir === "top") ny--;
          else if (dir === "right") nx++;
          else if (dir === "bottom") ny++;
          else if (dir === "left") nx--;

          if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && !visited[`${nx},${ny}`]) {
            maze[y][x][dir] = false;
            if (dir === "top") maze[ny][nx].bottom = false;
            else if (dir === "right") maze[ny][nx].left = false;
            else if (dir === "bottom") maze[ny][nx].top = false;
            else if (dir === "left") maze[ny][nx].right = false;
            carve(nx, ny, visited);
          }
        }
      }

      carve(player.x, player.y);
      exitCell = { x: cols - 1, y: rows - 1 };
    }

    function drawMaze() {
      const startX = player.x - halfVisible;
      const startY = player.y - halfVisible;
      ctx.clearRect(0, 0, width, height);
      ctx.save();
      ctx.translate(width / 2, height / 2);
      ctx.rotate(player.angle);
      ctx.translate(-cellSize / 2, -cellSize / 2);

      for (let y = 0; y < visibleCells; y++) {
        for (let x = 0; x < visibleCells; x++) {
          const mazeX = x + startX;
          const mazeY = y + startY;
          const cell = maze[mazeY]?.[mazeX];
          if (!cell) continue;

          const px = (x - halfVisible) * cellSize;
          const py = (y - halfVisible) * cellSize;

          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.beginPath();
          if (cell.top) {
            ctx.moveTo(px, py);
            ctx.lineTo(px + cellSize, py);
          }
          if (cell.right) {
            ctx.moveTo(px + cellSize, py);
            ctx.lineTo(px + cellSize, py + cellSize);
          }
          if (cell.bottom) {
            ctx.moveTo(px + cellSize, py + cellSize);
            ctx.lineTo(px, py + cellSize);
          }
          if (cell.left) {
            ctx.moveTo(px, py + cellSize);
            ctx.lineTo(px, py);
          }
          ctx.stroke();

          // Exit cell
          if (mazeX === exitCell.x && mazeY === exitCell.y) {
            ctx.fillStyle = "lime";
            ctx.beginPath();
            ctx.arc(px + cellSize / 2, py + cellSize / 2, 5, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      // Player triangle
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.moveTo(0, -10);
      ctx.lineTo(-7, 10);
      ctx.lineTo(7, 10);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function updateInfo() {
      document.getElementById("info").innerHTML =
        `Lat: ${player.lat?.toFixed(6) ?? "--"}<br>` +
        `Lon: ${player.lon?.toFixed(6) ?? "--"}<br>` +
        `Pasos: ${player.steps}`;
    }

    function distanceInMeters(lat1, lon1, lat2, lon2) {
  const earthRadius = 6371000; // metros
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const meanLat = (lat1 + lat2) / 2 * Math.PI / 180;

  const x = dLon * Math.cos(meanLat);
  const distance = Math.sqrt(x * x + dLat * dLat) * earthRadius;
  return distance;
}


    function angleBetween(lat1, lon1, lat2, lon2) {
      const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
      const x = Math.cos(lat1) * Math.sin(lat2) -
                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
      return Math.atan2(y, x);
    }

    function moveForward() {
      const dx = Math.round(Math.cos(player.angle));
      const dy = Math.round(Math.sin(player.angle));
      const nx = player.x + dx;
      const ny = player.y + dy;

      if (
        nx >= 0 && nx < cols &&
        ny >= 0 && ny < rows
      ) {
        const current = maze[player.y][player.x];
        if (
          (dx === 1 && !current.right) ||
          (dx === -1 && !current.left) ||
          (dy === 1 && !current.bottom) ||
          (dy === -1 && !current.top)
        ) {
          player.x = nx;
          player.y = ny;
          player.steps++;
        }
      }
    }

    function onPosition(pos) {
      const { latitude, longitude } = pos.coords;
      if (!player.lat || !player.lon) {
        player.lat = latitude;
        player.lon = longitude;
        lastLat = latitude;
        lastLon = longitude;
        return;
      }

      const dist = distanceInMeters(lastLat, lastLon, latitude, longitude);
      const angle = angleBetween(lastLat, lastLon, latitude, longitude);
      const diff = Math.abs(((angle - player.angle + Math.PI * 3) % (Math.PI * 2)) - Math.PI);

      if (dist >= 0.2 && diff < Math.PI / 4) {
        moveForward();
        lastLat = latitude;
        lastLon = longitude;
      }

      player.lat = latitude;
      player.lon = longitude;
    }

    navigator.geolocation.watchPosition(onPosition, console.error, {
      enableHighAccuracy: true,
      maximumAge: 0,
      timeout: 5000,
    });

    window.addEventListener("deviceorientation", (e) => {
      if (e.absolute || e.alpha !== null) {
        const angle = (360 - e.alpha) * Math.PI / 180;
        player.angle = angle;
      }
    });

    function animate() {
      drawMaze();
      updateInfo();
      requestAnimationFrame(animate);
    }

    createMaze();
    animate();
  </script>
</body>
</html>
