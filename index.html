<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Laberinto GPS</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let width, height;

function resizeCanvas() {
  width = window.innerWidth;
  height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

const cols = 21, rows = 21;
const cellSize = 40;
let maze = [];
let stack = [];

class Cell {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.walls = [true, true, true, true]; // top, right, bottom, left
    this.visited = false;
  }

  checkNeighbors() {
    const neighbors = [];

    const top = maze[index(this.x, this.y - 1)];
    const right = maze[index(this.x + 1, this.y)];
    const bottom = maze[index(this.x, this.y + 1)];
    const left = maze[index(this.x - 1, this.y)];

    if (top && !top.visited) neighbors.push(top);
    if (right && !right.visited) neighbors.push(right);
    if (bottom && !bottom.visited) neighbors.push(bottom);
    if (left && !left.visited) neighbors.push(left);

    if (neighbors.length > 0) {
      return neighbors[Math.floor(Math.random() * neighbors.length)];
    }
    return undefined;
  }
}

function index(x, y) {
  if (x < 0 || y < 0 || x >= cols || y >= rows) return -1;
  return x + y * cols;
}

function removeWalls(a, b) {
  const x = a.x - b.x;
  if (x === 1) {
    a.walls[3] = false;
    b.walls[1] = false;
  } else if (x === -1) {
    a.walls[1] = false;
    b.walls[3] = false;
  }

  const y = a.y - b.y;
  if (y === 1) {
    a.walls[0] = false;
    b.walls[2] = false;
  } else if (y === -1) {
    a.walls[2] = false;
    b.walls[0] = false;
  }
}

function generateMaze() {
  maze = [];
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      maze.push(new Cell(x, y));
    }
  }

  const start = maze[0];
  stack = [start];
  start.visited = true;

  while (stack.length > 0) {
    const current = stack[stack.length - 1];
    const next = current.checkNeighbors();

    if (next) {
      next.visited = true;
      stack.push(next);
      removeWalls(current, next);
    } else {
      stack.pop();
    }
  }
}
generateMaze();

let player = {
  x: Math.floor(cols / 2),
  y: Math.floor(rows / 2),
  dir: 0, // radians
  steps: 0
};

let exit = {
  x: cols - 1,
  y: Math.floor(rows / 2)
};

let lastLat = null, lastLon = null;

function drawMaze(centerX, centerY) {
  ctx.clearRect(0, 0, width, height);

  const viewSize = Math.min(width, height);
  const zoom = viewSize / (cellSize * 7); // muestra 7x7 celdas
  ctx.save();
  ctx.translate(width / 2, height / 2);
  ctx.scale(zoom, zoom);
  ctx.translate(-centerX * cellSize - cellSize / 2, -centerY * cellSize - cellSize / 2);

  maze.forEach(cell => {
    const x = cell.x * cellSize;
    const y = cell.y * cellSize;

    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;

    if (cell.walls[0]) drawLine(x, y, x + cellSize, y);       // top
    if (cell.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize); // right
    if (cell.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize); // bottom
    if (cell.walls[3]) drawLine(x, y + cellSize, x, y);       // left
  });

  // salida
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(exit.x * cellSize + cellSize / 2, exit.y * cellSize + cellSize / 2, 5, 0, Math.PI * 2);
  ctx.fill();

  // jugador
  drawPlayer();

  ctx.restore();
}

function drawLine(x1, y1, x2, y2) {
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}

function drawPlayer() {
  const x = player.x * cellSize + cellSize / 2;
  const y = player.y * cellSize + cellSize / 2;
  const size = 10;

  ctx.fillStyle = "red";
  ctx.beginPath();
  ctx.moveTo(x + Math.cos(player.dir) * size, y + Math.sin(player.dir) * size);
  ctx.lineTo(x + Math.cos(player.dir + Math.PI * 2 / 3) * size, y + Math.sin(player.dir + Math.PI * 2 / 3) * size);
  ctx.lineTo(x + Math.cos(player.dir - Math.PI * 2 / 3) * size, y + Math.sin(player.dir - Math.PI * 2 / 3) * size);
  ctx.closePath();
  ctx.fill();
}

// Movimiento GPS
function distance(lat1, lon1, lat2, lon2) {
  const R = 6371000; // m
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function moveForward() {
  const dirX = Math.round(Math.cos(player.dir));
  const dirY = Math.round(Math.sin(player.dir));
  const newX = player.x + dirX;
  const newY = player.y + dirY;

  const cell = maze[index(player.x, player.y)];
  const canMove =
    (dirX === 1 && !cell.walls[1]) ||
    (dirX === -1 && !cell.walls[3]) ||
    (dirY === 1 && !cell.walls[2]) ||
    (dirY === -1 && !cell.walls[0]);

  if (
    newX >= 0 && newX < cols &&
    newY >= 0 && newY < rows &&
    canMove
  ) {
    player.x = newX;
    player.y = newY;
    player.steps++;
  }
}

navigator.geolocation.watchPosition(pos => {
  const lat = pos.coords.latitude;
  const lon = pos.coords.longitude;

  if (lastLat !== null && lastLon !== null) {
    const dist = distance(lat, lon, lastLat, lastLon);
    const heading = Math.atan2(lat - lastLat, lon - lastLon);

    if (dist >= 0.25) {
      const angleDiff = Math.abs(player.dir - heading);
      if (angleDiff < Math.PI / 4) {
        moveForward();
      }
    }
  }

  lastLat = lat;
  lastLon = lon;
}, console.error, { enableHighAccuracy: true });

window.addEventListener("deviceorientation", e => {
  const angle = e.alpha;
  if (angle !== null) {
    player.dir = (angle * Math.PI / 180);
  }
});

function animate() {
  drawMaze(player.x, player.y);
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
