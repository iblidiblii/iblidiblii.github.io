<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Laberinto Dinámico</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: black;
    }

    canvas {
      display: block;
    }

    #countdown {
      position: absolute;
      top: 10px;
      right: 15px;
      color: #00ff00;
      font-size: 24px;
      font-family: monospace;
      background: rgba(0, 0, 0, 0.7);
      padding: 6px 10px;
      border-radius: 8px;
    }
  </style>
</head>
<body>
  <canvas id="mazeCanvas"></canvas>
  <div id="countdown">60</div>

  <script>
    const canvas = document.getElementById("mazeCanvas");
    const ctx = canvas.getContext("2d");
    let width, height;
    let cols = 21, rows = 21;
    let cellSize;
    let grid = [];
    let stack = [];
    let player = { x: Math.floor(cols / 2), y: Math.floor(rows / 2) };
    let viewOffset = { x: 0, y: 0 };
    let transitionFrames = 48;
    let isTransitioning = false;
    let prevGrid = null;
    let frame = 0;
    let exitCell = { x: cols - 1, y: rows - 1 };

    function resizeCanvas() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      cellSize = Math.min(width / 10, height / 10);
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    class Cell {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.walls = [true, true, true, true]; // top, right, bottom, left
        this.visited = false;
      }

      draw(offsetX, offsetY, styleGrid = grid, alpha = 1) {
        const x = this.x * cellSize - offsetX;
        const y = this.y * cellSize - offsetY;
        ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
        ctx.lineWidth = 1;

        if (this.walls[0]) drawLine(x, y, x + cellSize, y);             // top
        if (this.walls[1]) drawLine(x + cellSize, y, x + cellSize, y + cellSize); // right
        if (this.walls[2]) drawLine(x + cellSize, y + cellSize, x, y + cellSize); // bottom
        if (this.walls[3]) drawLine(x, y + cellSize, x, y);             // left
      }
    }

    function drawLine(x1, y1, x2, y2) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function index(x, y) {
      if (x < 0 || y < 0 || x >= cols || y >= rows) return null;
      return x + y * cols;
    }

    function createGrid() {
      grid = [];
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          grid.push(new Cell(x, y));
        }
      }
    }

    function getNeighbors(cell) {
      const neighbors = [];

      const directions = [
        { dx: 0, dy: -1, wall: 0, opposite: 2 }, // top
        { dx: 1, dy: 0, wall: 1, opposite: 3 },  // right
        { dx: 0, dy: 1, wall: 2, opposite: 0 },  // bottom
        { dx: -1, dy: 0, wall: 3, opposite: 1 }, // left
      ];

      for (const dir of directions.sort(() => Math.random() - 0.5)) {
        const nx = cell.x + dir.dx;
        const ny = cell.y + dir.dy;
        const neighbor = grid[index(nx, ny)];
        if (neighbor && !neighbor.visited) {
          neighbors.push({ cell: neighbor, wall: dir.wall, opposite: dir.opposite });
        }
      }

      return neighbors;
    }

    function generateMaze(cx, cy) {
      for (const cell of grid) {
        cell.visited = false;
        cell.walls = [true, true, true, true];
      }

      const start = grid[index(cx, cy)];
      stack = [start];
      start.visited = true;

      while (stack.length > 0) {
        const current = stack.pop();
        const neighbors = getNeighbors(current);

        if (neighbors.length > 0) {
          stack.push(current);

          const { cell: next, wall, opposite } = neighbors[0];
          current.walls[wall] = false;
          next.walls[opposite] = false;
          next.visited = true;
          stack.push(next);
        }
      }

      // Mantén una salida en una esquina
      exitCell = { x: cols - 1, y: rows - 1 };
      grid[index(exitCell.x, exitCell.y)].walls[1] = false; // abrir lado derecho
    }

    function drawMaze(alpha = 1, useGrid = grid) {
      ctx.clearRect(0, 0, width, height);
      let offsetX = player.x * cellSize - width / 2 + cellSize / 2;
      let offsetY = player.y * cellSize - height / 2 + cellSize / 2;
      viewOffset = { x: offsetX, y: offsetY };

      for (const cell of useGrid) {
        cell.draw(offsetX, offsetY, useGrid, alpha);
      }

      // dibujar jugador
      const px = player.x * cellSize - viewOffset.x + cellSize / 4;
      const py = player.y * cellSize - viewOffset.y + cellSize / 4;
      ctx.fillStyle = "lime";
      ctx.fillRect(px, py, cellSize / 2, cellSize / 2);

      // marcar salida
      if (!isTransitioning) {
        const ex = exitCell.x * cellSize - viewOffset.x + cellSize / 2;
        const ey = exitCell.y * cellSize - viewOffset.y + cellSize / 2;
        ctx.beginPath();
        ctx.arc(ex, ey, cellSize / 6, 0, 2 * Math.PI);
        ctx.fillStyle = "lime";
        ctx.fill();
      }
    }

    function animate() {
      if (isTransitioning && frame < transitionFrames) {
        const alpha = frame / transitionFrames;
        drawMaze(1 - alpha, prevGrid);
        drawMaze(alpha, grid);
        frame++;
        requestAnimationFrame(animate);
      } else {
        isTransitioning = false;
        drawMaze();
        requestAnimationFrame(animate);
      }
    }

    function startMazeTransition() {
      prevGrid = grid.map(cell => Object.assign(new Cell(cell.x, cell.y), {
        walls: [...cell.walls]
      }));
      createGrid();
      generateMaze(Math.floor(cols / 2), Math.floor(rows / 2));
      isTransitioning = true;
      frame = 0;
    }

    document.addEventListener("keydown", (e) => {
      if (isTransitioning) return;

      const dir = {
        ArrowUp: [0, -1, 0],
        ArrowRight: [1, 0, 1],
        ArrowDown: [0, 1, 2],
        ArrowLeft: [-1, 0, 3],
      }[e.key];

      if (!dir) return;

      const [dx, dy, wall] = dir;
      const nx = player.x + dx;
      const ny = player.y + dy;
      const current = grid[index(player.x, player.y)];
      const next = grid[index(nx, ny)];

      if (!current || !next || current.walls[wall]) return;
      player.x = nx;
      player.y = ny;
    });

    // TIMER + TRANSITION + COUNTDOWN
    let countdownValue = 60;
    function updateCountdown() {
      document.getElementById("countdown").textContent = countdownValue;
      countdownValue--;
      if (countdownValue < 0) {
        countdownValue = 60;
      }
    }

    function scheduleMazeTransition() {
      setTimeout(() => {
        startMazeTransition();
        scheduleMazeTransition();
      }, 60000);
    }

    // Start everything
    createGrid();
    generateMaze(Math.floor(cols / 2), Math.floor(rows / 2));
    animate();
    scheduleMazeTransition();
    setInterval(updateCountdown, 1000);
  </script>
</body>
</html>
